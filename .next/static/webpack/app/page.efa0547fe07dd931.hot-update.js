"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/webhookService.ts":
/*!****************************************!*\
  !*** ./src/services/webhookService.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOrCreateSessionId: function() { return /* binding */ getOrCreateSessionId; },\n/* harmony export */   sendMessageToWebhook: function() { return /* binding */ sendMessageToWebhook; }\n/* harmony export */ });\n/**\r\n * Serviço para comunicação com o webhook N8N\r\n */ const WEBHOOK_URL = \"https://webhook.agentemwd.com/webhook/9de471bd-4296-4cc8-bc40-f2ea1d19f6dd\";\nconst SESSION_ID_STORAGE_KEY = \"denzer_chat_session_id\";\nconst CHAT_API_URL = \"/api/chat/messages\";\n/**\r\n * Gera um ID único para a sessão ou recupera o existente do sessionStorage\r\n * O ID é único por sessão do navegador (recarrega quando a página é recarregada)\r\n * @returns ID único da sessão\r\n */ function getOrCreateSessionId() {\n    // Tenta recuperar o ID do sessionStorage\n    const storedSessionId = sessionStorage.getItem(SESSION_ID_STORAGE_KEY);\n    if (storedSessionId) {\n        return storedSessionId;\n    }\n    // Gera um novo ID único usando timestamp + random\n    const newSessionId = \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 15));\n    // Armazena no sessionStorage (apenas durante a sessão)\n    sessionStorage.setItem(SESSION_ID_STORAGE_KEY, newSessionId);\n    return newSessionId;\n}\n// Mensagens que indicam que o workflow foi iniciado mas ainda não há resposta\nconst WORKFLOW_STARTED_MESSAGES = [\n    \"workflow foi iniciado\",\n    \"workflow iniciado\",\n    \"workflow started\",\n    \"processando\",\n    \"processando sua mensagem\",\n    \"aguarde\"\n];\n/**\r\n * Verifica se a resposta indica que o workflow foi iniciado mas ainda não há resposta final\r\n */ function isWorkflowStartedResponse(response) {\n    const lowerResponse = response.toLowerCase();\n    return WORKFLOW_STARTED_MESSAGES.some((msg)=>lowerResponse.includes(msg));\n}\n/**\r\n * Faz polling para verificar se há mensagens disponíveis\r\n * IMPORTANTE: Apenas verifica status, NÃO inicia novas execuções\r\n * @param sessionId - ID da sessão\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida\r\n * @param maxAttempts - Número máximo de tentativas (padrão: 30 = 60 segundos)\r\n * @param intervalMs - Intervalo entre tentativas em ms (padrão: 2000 = 2 segundos)\r\n * @param emptyAttemptsToStop - Número de tentativas vazias consecutivas para parar (padrão: 2)\r\n * @returns true se recebeu mensagens, false se timeout\r\n */ async function pollForMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 30, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;\n    console.log(\"\\uD83D\\uDD04 Iniciando polling APENAS para verificar status. SessionId: \".concat(sessionId, \", m\\xe1ximo \").concat(maxAttempts, \" tentativas\"));\n    console.log(\"\\uD83D\\uDCCB Mensagens j\\xe1 recebidas na primeira resposta: \".concat(initialMessages.length));\n    const receivedMessages = new Set(initialMessages); // Inclui mensagens já recebidas para evitar duplicatas\n    let consecutiveEmptyAttempts = 0; // Contador de tentativas consecutivas sem novas mensagens\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // Aguarda antes de fazer a próxima tentativa (exceto na primeira)\n        if (attempt > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, intervalMs));\n        }\n        try {\n            // IMPORTANTE: Apenas verifica status, NÃO envia mensagem nem agentType\n            // Isso evita iniciar novas execuções do workflow\n            const response = await fetch(WEBHOOK_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    sessionId: sessionId,\n                    checkStatus: true,\n                    timestamp: new Date().toISOString()\n                })\n            });\n            if (response.ok) {\n                const contentType = response.headers.get(\"content-type\");\n                let data;\n                if (contentType && contentType.includes(\"application/json\")) {\n                    data = await response.json();\n                } else {\n                    const text = await response.text();\n                    data = text;\n                }\n                // Processa múltiplas mensagens se vierem em array\n                const messages = extractMessages(data);\n                console.log(\"\\uD83D\\uDCE6 Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": \").concat(messages.length, \" mensagens extra\\xeddas\"));\n                let newMessagesCount = 0;\n                // Chama o callback para cada nova mensagem\n                messages.forEach((msg)=>{\n                    const trimmedMsg = msg.trim();\n                    if (trimmedMsg.length > 0 && !isWorkflowStartedResponse(trimmedMsg) && trimmedMsg.toLowerCase() !== \"null\" && trimmedMsg.toLowerCase() !== \"undefined\" && !receivedMessages.has(trimmedMsg)) {\n                        receivedMessages.add(trimmedMsg);\n                        newMessagesCount++;\n                        console.log(\"✅ Nova mensagem \".concat(newMessagesCount, \" recebida na tentativa \").concat(attempt + 1, \":\"), trimmedMsg.substring(0, 100));\n                        onNewMessage(trimmedMsg);\n                    }\n                });\n                // Se recebeu novas mensagens, reseta o contador de tentativas vazias\n                if (newMessagesCount > 0) {\n                    consecutiveEmptyAttempts = 0;\n                    console.log(\"\\uD83D\\uDCCA Total de mensagens recebidas at\\xe9 agora: \".concat(receivedMessages.size));\n                } else {\n                    consecutiveEmptyAttempts++;\n                    console.log(\"⏳ Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": Sem novas mensagens (\").concat(consecutiveEmptyAttempts, \"/\").concat(emptyAttemptsToStop, \" tentativas vazias consecutivas)\"));\n                }\n                // Para o polling se não houver novas mensagens por várias tentativas consecutivas\n                if (consecutiveEmptyAttempts >= emptyAttemptsToStop) {\n                    if (receivedMessages.size > 0) {\n                        console.log(\"⏹️ Parando polling: \".concat(emptyAttemptsToStop, \" tentativas consecutivas sem novas mensagens. Total: \").concat(receivedMessages.size, \" mensagens recebidas\"));\n                        break;\n                    } else if (attempt >= 5) {\n                        // Se não recebeu nenhuma mensagem após 5 tentativas, também para\n                        console.log(\"⏹️ Parando polling: Nenhuma mensagem recebida ap\\xf3s \".concat(attempt + 1, \" tentativas\"));\n                        break;\n                    }\n                }\n            } else {\n                console.warn(\"⚠️ Tentativa \".concat(attempt + 1, \": Status \").concat(response.status));\n            }\n        } catch (error) {\n            console.warn(\"⚠️ Erro na tentativa \".concat(attempt + 1, \" de polling:\"), error);\n        // Continua tentando mesmo com erro\n        }\n    }\n    const hasMessages = receivedMessages.size > 0;\n    if (!hasMessages) {\n        console.warn(\"⏱️ Timeout: N\\xe3o foi poss\\xedvel obter mensagens ap\\xf3s \".concat(maxAttempts, \" tentativas\"));\n    } else {\n        console.log(\"✅ Polling finalizado. Total de \".concat(receivedMessages.size, \" mensagens recebidas\"));\n    }\n    return hasMessages;\n}\n/**\r\n * Extrai múltiplas mensagens do formato retornado pelo N8N\r\n * Suporta arrays de mensagens ou mensagem única\r\n */ function extractMessages(data) {\n    console.log(\"\\uD83D\\uDD0D extractMessages chamado com:\", typeof data, Array.isArray(data) ? \"array[\".concat(data.length, \"]\") : data);\n    // Se for string, tenta parsear como JSON\n    if (typeof data === \"string\") {\n        try {\n            const parsed = JSON.parse(data);\n            return extractMessages(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna como array com uma mensagem\n            return data.trim() ? [\n                data\n            ] : [];\n        }\n    }\n    // Se for um array, processa cada item\n    if (Array.isArray(data)) {\n        console.log(\"\\uD83D\\uDCE6 Processando array com \".concat(data.length, \" itens\"));\n        const messages = [];\n        data.forEach((item, index)=>{\n            console.log(\"\\uD83D\\uDD0D Processando item \".concat(index + 1, \"/\").concat(data.length, \":\"), item);\n            const extracted = extractResponse(item);\n            console.log(\"\\uD83D\\uDCDD Item \".concat(index + 1, \" extra\\xeddo:\"), extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n            if (extracted && extracted.trim()) {\n                messages.push(extracted);\n            } else {\n                console.log(\"⚠️ Item \".concat(index + 1, \" n\\xe3o tinha conte\\xfado v\\xe1lido\"));\n            }\n        });\n        console.log(\"✅ Total de \".concat(messages.length, \" mensagens extra\\xeddas do array\"));\n        return messages;\n    }\n    // Se for objeto, extrai a mensagem\n    if (data && typeof data === \"object\") {\n        const extracted = extractResponse(data);\n        console.log(\"\\uD83D\\uDCDD Objeto extra\\xeddo:\", extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n        return extracted && extracted.trim() ? [\n            extracted\n        ] : [];\n    }\n    console.log(\"⚠️ Tipo de dados n\\xe3o reconhecido, retornando array vazio\");\n    return [];\n}\n/**\r\n * Envia uma mensagem para o webhook N8N e recebe múltiplas mensagens separadas\r\n * Se a resposta inicial for \"workflow iniciado\", faz polling até receber as mensagens\r\n * @param message - A mensagem do usuário\r\n * @param agentType - Tipo do agente IA (sdr, ecommerce, agendamento)\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida da IA\r\n * @param onPolling - Callback chamado durante o polling (para animação)\r\n */ async function sendMessageToWebhook(message, agentType, onNewMessage, onPolling) {\n    try {\n        // Obtém ou cria o ID único da sessão\n        const sessionId = getOrCreateSessionId();\n        const payload = {\n            message: message.trim(),\n            timestamp: new Date().toISOString(),\n            sessionId: sessionId,\n            agentType: agentType\n        };\n        // Log para debug\n        console.log(\"Enviando mensagem para webhook:\", {\n            url: WEBHOOK_URL,\n            method: \"POST\",\n            payload: payload\n        });\n        const response = await fetch(WEBHOOK_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload)\n        });\n        console.log(\"Resposta do webhook:\", {\n            status: response.status,\n            statusText: response.statusText,\n            ok: response.ok\n        });\n        if (!response.ok) {\n            const errorText = await response.text().catch(()=>response.statusText);\n            console.error(\"Erro na resposta do webhook:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Erro HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Tenta parsear como JSON, mas também suporta texto simples\n        let data;\n        const contentType = response.headers.get(\"content-type\");\n        try {\n            if (contentType && contentType.includes(\"application/json\")) {\n                data = await response.json();\n            } else {\n                const text = await response.text();\n                data = text;\n            }\n        } catch (parseError) {\n            console.error(\"Erro ao parsear resposta:\", parseError);\n            throw new Error(\"Erro ao processar resposta do webhook\");\n        }\n        console.log(\"Dados parseados:\", data);\n        // Extrai as mensagens do formato retornado pelo N8N\n        const messages = extractMessages(data);\n        console.log(\"Mensagens extra\\xeddas:\", messages);\n        // Verifica se o workflow foi iniciado (indica que mais mensagens podem vir)\n        const isWorkflowStarted = messages.some((msg)=>isWorkflowStartedResponse(msg));\n        const validMessages = messages.filter((msg)=>!isWorkflowStartedResponse(msg));\n        console.log(\"\\uD83D\\uDCCA Workflow iniciado? \".concat(isWorkflowStarted, \", Mensagens v\\xe1lidas na resposta inicial: \").concat(validMessages.length));\n        // Processa mensagens da resposta inicial primeiro (se houver)\n        if (validMessages.length > 0) {\n            console.log(\"\\uD83D\\uDCE8 Processando \".concat(validMessages.length, \" mensagens da resposta inicial\"));\n            validMessages.forEach((msg, index)=>{\n                console.log(\"\\uD83D\\uDCE4 Enviando mensagem \".concat(index + 1, \"/\").concat(validMessages.length, \" da resposta inicial:\"), msg.substring(0, 100));\n                onNewMessage(msg);\n                console.log(\"✅ Callback onNewMessage chamado para mensagem \".concat(index + 1));\n            });\n            console.log(\"✅ Todas as \".concat(validMessages.length, \" mensagens da resposta inicial foram enviadas\"));\n        } else {\n            console.log(\"⚠️ Nenhuma mensagem v\\xe1lida encontrada na resposta inicial\");\n        }\n        // Sempre fazemos polling na API interna de mensagens para trazer as respostas que o fluxo enviou via HTTP Request1\n        console.log(\"\\uD83D\\uDD04 Iniciando polling na API interna /api/chat/messages para buscar respostas do fluxo\");\n        if (onPolling) onPolling(true);\n        await pollChatMessages(sessionId, onNewMessage, validMessages);\n        if (onPolling) onPolling(false);\n    } catch (error) {\n        console.error(\"Erro completo ao enviar mensagem para webhook:\", {\n            error,\n            message: error instanceof Error ? error.message : \"Erro desconhecido\",\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        throw error;\n    }\n}\n/**\r\n * Faz polling na API interna (/api/chat/messages) para buscar mensagens persistidas pelo fluxo\r\n */ async function pollChatMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 50, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1500, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 6, minAttemptsBeforeStop = arguments.length > 6 && arguments[6] !== void 0 // garante ao menos 5 tentativas antes de parar\n     ? arguments[6] : 5;\n    let cursor = -1;\n    let consecutiveEmpty = 0;\n    const received = new Set(initialMessages);\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // espera entre tentativas, exceto na primeira\n        if (attempt > 0) {\n            await new Promise((r)=>setTimeout(r, intervalMs));\n        }\n        try {\n            const url = \"\".concat(CHAT_API_URL, \"?sessionId=\").concat(encodeURIComponent(sessionId), \"&cursor=\").concat(cursor);\n            const resp = await fetch(url, {\n                method: \"GET\"\n            });\n            if (!resp.ok) {\n                console.warn(\"⚠️ Polling chat API status \".concat(resp.status, \" na tentativa \").concat(attempt + 1));\n                continue;\n            }\n            const data = await resp.json();\n            var _data_messages;\n            const messages = (_data_messages = data === null || data === void 0 ? void 0 : data.messages) !== null && _data_messages !== void 0 ? _data_messages : [];\n            const lastIdx = typeof (data === null || data === void 0 ? void 0 : data.lastIdx) === \"number\" ? data.lastIdx : cursor;\n            let newCount = 0;\n            messages.forEach((m)=>{\n                var _m_text;\n                const txt = ((_m_text = m === null || m === void 0 ? void 0 : m.text) !== null && _m_text !== void 0 ? _m_text : \"\").trim();\n                if (txt && !received.has(txt) && !isWorkflowStartedResponse(txt) && txt.toLowerCase() !== \"null\") {\n                    received.add(txt);\n                    newCount++;\n                    onNewMessage(txt);\n                }\n            });\n            if (newCount > 0) {\n                cursor = lastIdx;\n                consecutiveEmpty = 0;\n            } else {\n                consecutiveEmpty++;\n            }\n            if (consecutiveEmpty >= emptyAttemptsToStop && attempt + 1 >= minAttemptsBeforeStop) {\n                break;\n            }\n        } catch (err) {\n            console.warn(\"⚠️ Erro ao fazer polling da chat API na tentativa \".concat(attempt + 1, \":\"), err);\n        // continua tentando\n        }\n    }\n}\n/**\r\n * Extrai a resposta do formato retornado pelo N8N\r\n * Suporta diferentes formatos de resposta, incluindo arrays JSON\r\n */ function extractResponse(data) {\n    // Se for string, tenta parsear como JSON primeiro\n    if (typeof data === \"string\") {\n        // Tenta parsear como JSON\n        try {\n            const parsed = JSON.parse(data);\n            // Se parseou com sucesso, processa o objeto/array\n            return extractResponse(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna a string como está\n            return data;\n        }\n    }\n    // Se for um array, pega o primeiro elemento\n    if (Array.isArray(data) && data.length > 0) {\n        const firstItem = data[0];\n        // Se o primeiro item tiver campo \"output\", retorna ele\n        if (firstItem && typeof firstItem === \"object\" && \"output\" in firstItem) {\n            return String(firstItem.output || \"\");\n        }\n        // Se não, tenta extrair do primeiro item\n        return extractResponse(firstItem);\n    }\n    // Se for objeto, tenta diferentes campos comuns de resposta\n    if (data && typeof data === \"object\") {\n        // Prioriza o campo \"text\" (formato comum do N8N)\n        if (\"text\" in data && data.text) {\n            console.log('\\uD83D\\uDCDD Campo \"text\" encontrado:', String(data.text).substring(0, 100));\n            return String(data.text);\n        }\n        // Prioriza o campo \"output\" se existir\n        if (\"output\" in data && data.output) {\n            return String(data.output);\n        }\n        // Tenta outros campos comuns\n        if (data.response) return String(data.response);\n        if (data.message) return String(data.message);\n        // Tenta campos aninhados\n        if (data.output && typeof data.output === \"object\") {\n            if (\"message\" in data.output) return String(data.output.message);\n            if (\"response\" in data.output) return String(data.output.response);\n            if (\"text\" in data.output) return String(data.output.text);\n        }\n    }\n    // Se não encontrar nenhum campo conhecido, retorna o JSON stringificado\n    return JSON.stringify(data);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWJob29rU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRUQsTUFBTUEsY0FBYztBQUNwQixNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMsZUFBZTtBQVdyQjs7OztDQUlDLEdBQ00sU0FBU0M7SUFDZCx5Q0FBeUM7SUFDekMsTUFBTUMsa0JBQWtCQyxlQUFlQyxPQUFPLENBQUNMO0lBRS9DLElBQUlHLGlCQUFpQjtRQUNuQixPQUFPQTtJQUNUO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU1HLGVBQWUsV0FBeUJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUErQyxPQUE1Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUc7SUFFdEYsdURBQXVEO0lBQ3ZEUixlQUFlUyxPQUFPLENBQUNiLHdCQUF3Qk07SUFFL0MsT0FBT0E7QUFDVDtBQWFBLDhFQUE4RTtBQUM5RSxNQUFNUSw0QkFBNEI7SUFDaEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRDs7Q0FFQyxHQUNELFNBQVNDLDBCQUEwQkMsUUFBZ0I7SUFDakQsTUFBTUMsZ0JBQWdCRCxTQUFTRSxXQUFXO0lBQzFDLE9BQU9KLDBCQUEwQkssSUFBSSxDQUFDQyxDQUFBQSxNQUFPSCxjQUFjSSxRQUFRLENBQUNEO0FBQ3RFO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsZUFBZUUsZ0JBQ2JDLFNBQWlCLEVBQ2pCQyxZQUF1QztRQUN2Q0Msa0JBQUFBLGlFQUE0QixFQUFFLEVBQzlCQyxjQUFBQSxpRUFBc0IsSUFDdEJDLGFBQUFBLGlFQUFxQixNQUNyQkMsc0JBQUFBLGlFQUE4QjtJQUU5QkMsUUFBUUMsR0FBRyxDQUFDLDJFQUFzRkosT0FBckJILFdBQVUsZ0JBQXVCLE9BQVpHLGFBQVk7SUFDOUdHLFFBQVFDLEdBQUcsQ0FBQyxnRUFBMEUsT0FBdkJMLGdCQUFnQk0sTUFBTTtJ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b29rU2VydmljZS50cz81Y2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXJ2acOnbyBwYXJhIGNvbXVuaWNhw6fDo28gY29tIG8gd2ViaG9vayBOOE5cclxuICovXHJcblxyXG5jb25zdCBXRUJIT09LX1VSTCA9IFwiaHR0cHM6Ly93ZWJob29rLmFnZW50ZW13ZC5jb20vd2ViaG9vay85ZGU0NzFiZC00Mjk2LTRjYzgtYmM0MC1mMmVhMWQxOWY2ZGRcIjtcclxuY29uc3QgU0VTU0lPTl9JRF9TVE9SQUdFX0tFWSA9IFwiZGVuemVyX2NoYXRfc2Vzc2lvbl9pZFwiO1xyXG5jb25zdCBDSEFUX0FQSV9VUkwgPSBcIi9hcGkvY2hhdC9tZXNzYWdlc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgQWdlbnRUeXBlID0gXCJzZHJcIiB8IFwiZWNvbW1lcmNlXCIgfCBcImFnZW5kYW1lbnRvXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdlYmhvb2tNZXNzYWdlIHtcclxuICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XHJcbiAgYWdlbnRUeXBlOiBBZ2VudFR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXJhIHVtIElEIMO6bmljbyBwYXJhIGEgc2Vzc8OjbyBvdSByZWN1cGVyYSBvIGV4aXN0ZW50ZSBkbyBzZXNzaW9uU3RvcmFnZVxyXG4gKiBPIElEIMOpIMO6bmljbyBwb3Igc2Vzc8OjbyBkbyBuYXZlZ2Fkb3IgKHJlY2FycmVnYSBxdWFuZG8gYSBww6FnaW5hIMOpIHJlY2FycmVnYWRhKVxyXG4gKiBAcmV0dXJucyBJRCDDum5pY28gZGEgc2Vzc8Ojb1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yQ3JlYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XHJcbiAgLy8gVGVudGEgcmVjdXBlcmFyIG8gSUQgZG8gc2Vzc2lvblN0b3JhZ2VcclxuICBjb25zdCBzdG9yZWRTZXNzaW9uSWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNFU1NJT05fSURfU1RPUkFHRV9LRVkpO1xyXG4gIFxyXG4gIGlmIChzdG9yZWRTZXNzaW9uSWQpIHtcclxuICAgIHJldHVybiBzdG9yZWRTZXNzaW9uSWQ7XHJcbiAgfVxyXG5cclxuICAvLyBHZXJhIHVtIG5vdm8gSUQgw7puaWNvIHVzYW5kbyB0aW1lc3RhbXAgKyByYW5kb21cclxuICBjb25zdCBuZXdTZXNzaW9uSWQgPSBgc2Vzc2lvbl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KX1gO1xyXG4gIFxyXG4gIC8vIEFybWF6ZW5hIG5vIHNlc3Npb25TdG9yYWdlIChhcGVuYXMgZHVyYW50ZSBhIHNlc3PDo28pXHJcbiAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShTRVNTSU9OX0lEX1NUT1JBR0VfS0VZLCBuZXdTZXNzaW9uSWQpO1xyXG4gIFxyXG4gIHJldHVybiBuZXdTZXNzaW9uSWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va1Jlc3BvbnNlIHtcclxuICByZXNwb25zZT86IHN0cmluZztcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG4gIHRleHQ/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIG91dHB1dD86IHtcclxuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgICByZXNwb25zZT86IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG4vLyBNZW5zYWdlbnMgcXVlIGluZGljYW0gcXVlIG8gd29ya2Zsb3cgZm9pIGluaWNpYWRvIG1hcyBhaW5kYSBuw6NvIGjDoSByZXNwb3N0YVxyXG5jb25zdCBXT1JLRkxPV19TVEFSVEVEX01FU1NBR0VTID0gW1xyXG4gIFwid29ya2Zsb3cgZm9pIGluaWNpYWRvXCIsXHJcbiAgXCJ3b3JrZmxvdyBpbmljaWFkb1wiLFxyXG4gIFwid29ya2Zsb3cgc3RhcnRlZFwiLFxyXG4gIFwicHJvY2Vzc2FuZG9cIixcclxuICBcInByb2Nlc3NhbmRvIHN1YSBtZW5zYWdlbVwiLFxyXG4gIFwiYWd1YXJkZVwiLFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWNhIHNlIGEgcmVzcG9zdGEgaW5kaWNhIHF1ZSBvIHdvcmtmbG93IGZvaSBpbmljaWFkbyBtYXMgYWluZGEgbsOjbyBow6EgcmVzcG9zdGEgZmluYWxcclxuICovXHJcbmZ1bmN0aW9uIGlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGxvd2VyUmVzcG9uc2UgPSByZXNwb25zZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBXT1JLRkxPV19TVEFSVEVEX01FU1NBR0VTLnNvbWUobXNnID0+IGxvd2VyUmVzcG9uc2UuaW5jbHVkZXMobXNnKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYXogcG9sbGluZyBwYXJhIHZlcmlmaWNhciBzZSBow6EgbWVuc2FnZW5zIGRpc3BvbsOtdmVpc1xyXG4gKiBJTVBPUlRBTlRFOiBBcGVuYXMgdmVyaWZpY2Egc3RhdHVzLCBOw4NPIGluaWNpYSBub3ZhcyBleGVjdcOnw7Vlc1xyXG4gKiBAcGFyYW0gc2Vzc2lvbklkIC0gSUQgZGEgc2Vzc8Ojb1xyXG4gKiBAcGFyYW0gb25OZXdNZXNzYWdlIC0gQ2FsbGJhY2sgY2hhbWFkbyBwYXJhIGNhZGEgbm92YSBtZW5zYWdlbSByZWNlYmlkYVxyXG4gKiBAcGFyYW0gbWF4QXR0ZW1wdHMgLSBOw7ptZXJvIG3DoXhpbW8gZGUgdGVudGF0aXZhcyAocGFkcsOjbzogMzAgPSA2MCBzZWd1bmRvcylcclxuICogQHBhcmFtIGludGVydmFsTXMgLSBJbnRlcnZhbG8gZW50cmUgdGVudGF0aXZhcyBlbSBtcyAocGFkcsOjbzogMjAwMCA9IDIgc2VndW5kb3MpXHJcbiAqIEBwYXJhbSBlbXB0eUF0dGVtcHRzVG9TdG9wIC0gTsO6bWVybyBkZSB0ZW50YXRpdmFzIHZhemlhcyBjb25zZWN1dGl2YXMgcGFyYSBwYXJhciAocGFkcsOjbzogMilcclxuICogQHJldHVybnMgdHJ1ZSBzZSByZWNlYmV1IG1lbnNhZ2VucywgZmFsc2Ugc2UgdGltZW91dFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcG9sbEZvck1lc3NhZ2VzKFxyXG4gIHNlc3Npb25JZDogc3RyaW5nLFxyXG4gIG9uTmV3TWVzc2FnZTogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcclxuICBpbml0aWFsTWVzc2FnZXM6IHN0cmluZ1tdID0gW10sIC8vIE1lbnNhZ2VucyBqw6EgcmVjZWJpZGFzIG5hIHByaW1laXJhIHJlc3Bvc3RhXHJcbiAgbWF4QXR0ZW1wdHM6IG51bWJlciA9IDMwLFxyXG4gIGludGVydmFsTXM6IG51bWJlciA9IDIwMDAsXHJcbiAgZW1wdHlBdHRlbXB0c1RvU3RvcDogbnVtYmVyID0gMlxyXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICBjb25zb2xlLmxvZyhg8J+UhCBJbmljaWFuZG8gcG9sbGluZyBBUEVOQVMgcGFyYSB2ZXJpZmljYXIgc3RhdHVzLiBTZXNzaW9uSWQ6ICR7c2Vzc2lvbklkfSwgbcOheGltbyAke21heEF0dGVtcHRzfSB0ZW50YXRpdmFzYCk7XHJcbiAgY29uc29sZS5sb2coYPCfk4sgTWVuc2FnZW5zIGrDoSByZWNlYmlkYXMgbmEgcHJpbWVpcmEgcmVzcG9zdGE6ICR7aW5pdGlhbE1lc3NhZ2VzLmxlbmd0aH1gKTtcclxuICBcclxuICBjb25zdCByZWNlaXZlZE1lc3NhZ2VzID0gbmV3IFNldDxzdHJpbmc+KGluaXRpYWxNZXNzYWdlcyk7IC8vIEluY2x1aSBtZW5zYWdlbnMgasOhIHJlY2ViaWRhcyBwYXJhIGV2aXRhciBkdXBsaWNhdGFzXHJcbiAgbGV0IGNvbnNlY3V0aXZlRW1wdHlBdHRlbXB0cyA9IDA7IC8vIENvbnRhZG9yIGRlIHRlbnRhdGl2YXMgY29uc2VjdXRpdmFzIHNlbSBub3ZhcyBtZW5zYWdlbnNcclxuICBcclxuICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcclxuICAgIC8vIEFndWFyZGEgYW50ZXMgZGUgZmF6ZXIgYSBwcsOzeGltYSB0ZW50YXRpdmEgKGV4Y2V0byBuYSBwcmltZWlyYSlcclxuICAgIGlmIChhdHRlbXB0ID4gMCkge1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWxNcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIElNUE9SVEFOVEU6IEFwZW5hcyB2ZXJpZmljYSBzdGF0dXMsIE7Dg08gZW52aWEgbWVuc2FnZW0gbmVtIGFnZW50VHlwZVxyXG4gICAgICAvLyBJc3NvIGV2aXRhIGluaWNpYXIgbm92YXMgZXhlY3XDp8O1ZXMgZG8gd29ya2Zsb3dcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChXRUJIT09LX1VSTCwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcclxuICAgICAgICAgIGNoZWNrU3RhdHVzOiB0cnVlLCAvLyBJbmRpY2EgcXVlIMOpIEFQRU5BUyB1bWEgdmVyaWZpY2HDp8OjbyBkZSBzdGF0dXNcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XHJcbiAgICAgICAgbGV0IGRhdGE6IFdlYmhvb2tSZXNwb25zZSB8IHN0cmluZyB8IGFueTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xyXG4gICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICAgIGRhdGEgPSB0ZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJvY2Vzc2EgbcO6bHRpcGxhcyBtZW5zYWdlbnMgc2UgdmllcmVtIGVtIGFycmF5XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBleHRyYWN0TWVzc2FnZXMoZGF0YSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk6YgVGVudGF0aXZhICR7YXR0ZW1wdCArIDF9LyR7bWF4QXR0ZW1wdHN9OiAke21lc3NhZ2VzLmxlbmd0aH0gbWVuc2FnZW5zIGV4dHJhw61kYXNgKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgbmV3TWVzc2FnZXNDb3VudCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hhbWEgbyBjYWxsYmFjayBwYXJhIGNhZGEgbm92YSBtZW5zYWdlbVxyXG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG1zZzogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB0cmltbWVkTXNnID0gbXNnLnRyaW0oKTtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgdHJpbW1lZE1zZy5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICFpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKHRyaW1tZWRNc2cpICYmXHJcbiAgICAgICAgICAgIHRyaW1tZWRNc2cudG9Mb3dlckNhc2UoKSAhPT0gXCJudWxsXCIgJiZcclxuICAgICAgICAgICAgdHJpbW1lZE1zZy50b0xvd2VyQ2FzZSgpICE9PSBcInVuZGVmaW5lZFwiICYmXHJcbiAgICAgICAgICAgICFyZWNlaXZlZE1lc3NhZ2VzLmhhcyh0cmltbWVkTXNnKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJlY2VpdmVkTWVzc2FnZXMuYWRkKHRyaW1tZWRNc2cpO1xyXG4gICAgICAgICAgICBuZXdNZXNzYWdlc0NvdW50Kys7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTm92YSBtZW5zYWdlbSAke25ld01lc3NhZ2VzQ291bnR9IHJlY2ViaWRhIG5hIHRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfTpgLCB0cmltbWVkTXNnLnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgICAgICAgICAgb25OZXdNZXNzYWdlKHRyaW1tZWRNc2cpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNlIHJlY2ViZXUgbm92YXMgbWVuc2FnZW5zLCByZXNldGEgbyBjb250YWRvciBkZSB0ZW50YXRpdmFzIHZhemlhc1xyXG4gICAgICAgIGlmIChuZXdNZXNzYWdlc0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgY29uc2VjdXRpdmVFbXB0eUF0dGVtcHRzID0gMDtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFRvdGFsIGRlIG1lbnNhZ2VucyByZWNlYmlkYXMgYXTDqSBhZ29yYTogJHtyZWNlaXZlZE1lc3NhZ2VzLnNpemV9YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNlY3V0aXZlRW1wdHlBdHRlbXB0cysrO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYOKPsyBUZW50YXRpdmEgJHthdHRlbXB0ICsgMX0vJHttYXhBdHRlbXB0c306IFNlbSBub3ZhcyBtZW5zYWdlbnMgKCR7Y29uc2VjdXRpdmVFbXB0eUF0dGVtcHRzfS8ke2VtcHR5QXR0ZW1wdHNUb1N0b3B9IHRlbnRhdGl2YXMgdmF6aWFzIGNvbnNlY3V0aXZhcylgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUGFyYSBvIHBvbGxpbmcgc2UgbsOjbyBob3V2ZXIgbm92YXMgbWVuc2FnZW5zIHBvciB2w6FyaWFzIHRlbnRhdGl2YXMgY29uc2VjdXRpdmFzXHJcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRW1wdHlBdHRlbXB0cyA+PSBlbXB0eUF0dGVtcHRzVG9TdG9wKSB7XHJcbiAgICAgICAgICBpZiAocmVjZWl2ZWRNZXNzYWdlcy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4o+577iPIFBhcmFuZG8gcG9sbGluZzogJHtlbXB0eUF0dGVtcHRzVG9TdG9wfSB0ZW50YXRpdmFzIGNvbnNlY3V0aXZhcyBzZW0gbm92YXMgbWVuc2FnZW5zLiBUb3RhbDogJHtyZWNlaXZlZE1lc3NhZ2VzLnNpemV9IG1lbnNhZ2VucyByZWNlYmlkYXNgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dGVtcHQgPj0gNSkge1xyXG4gICAgICAgICAgICAvLyBTZSBuw6NvIHJlY2ViZXUgbmVuaHVtYSBtZW5zYWdlbSBhcMOzcyA1IHRlbnRhdGl2YXMsIHRhbWLDqW0gcGFyYVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4o+577iPIFBhcmFuZG8gcG9sbGluZzogTmVuaHVtYSBtZW5zYWdlbSByZWNlYmlkYSBhcMOzcyAke2F0dGVtcHQgKyAxfSB0ZW50YXRpdmFzYCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBUZW50YXRpdmEgJHthdHRlbXB0ICsgMX06IFN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRXJybyBuYSB0ZW50YXRpdmEgJHthdHRlbXB0ICsgMX0gZGUgcG9sbGluZzpgLCBlcnJvcik7XHJcbiAgICAgIC8vIENvbnRpbnVhIHRlbnRhbmRvIG1lc21vIGNvbSBlcnJvXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYXNNZXNzYWdlcyA9IHJlY2VpdmVkTWVzc2FnZXMuc2l6ZSA+IDA7XHJcbiAgaWYgKCFoYXNNZXNzYWdlcykge1xyXG4gICAgY29uc29sZS53YXJuKGDij7HvuI8gVGltZW91dDogTsOjbyBmb2kgcG9zc8OtdmVsIG9idGVyIG1lbnNhZ2VucyBhcMOzcyAke21heEF0dGVtcHRzfSB0ZW50YXRpdmFzYCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnNvbGUubG9nKGDinIUgUG9sbGluZyBmaW5hbGl6YWRvLiBUb3RhbCBkZSAke3JlY2VpdmVkTWVzc2FnZXMuc2l6ZX0gbWVuc2FnZW5zIHJlY2ViaWRhc2ApO1xyXG4gIH1cclxuICByZXR1cm4gaGFzTWVzc2FnZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWkgbcO6bHRpcGxhcyBtZW5zYWdlbnMgZG8gZm9ybWF0byByZXRvcm5hZG8gcGVsbyBOOE5cclxuICogU3Vwb3J0YSBhcnJheXMgZGUgbWVuc2FnZW5zIG91IG1lbnNhZ2VtIMO6bmljYVxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdE1lc3NhZ2VzKGRhdGE6IGFueSk6IHN0cmluZ1tdIHtcclxuICBjb25zb2xlLmxvZyhcIvCflI0gZXh0cmFjdE1lc3NhZ2VzIGNoYW1hZG8gY29tOlwiLCB0eXBlb2YgZGF0YSwgQXJyYXkuaXNBcnJheShkYXRhKSA/IGBhcnJheVske2RhdGEubGVuZ3RofV1gIDogZGF0YSk7XHJcbiAgXHJcbiAgLy8gU2UgZm9yIHN0cmluZywgdGVudGEgcGFyc2VhciBjb21vIEpTT05cclxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgIHJldHVybiBleHRyYWN0TWVzc2FnZXMocGFyc2VkKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICAvLyBTZSBuw6NvIGZvciBKU09OIHbDoWxpZG8sIHJldG9ybmEgY29tbyBhcnJheSBjb20gdW1hIG1lbnNhZ2VtXHJcbiAgICAgIHJldHVybiBkYXRhLnRyaW0oKSA/IFtkYXRhXSA6IFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2UgZm9yIHVtIGFycmF5LCBwcm9jZXNzYSBjYWRhIGl0ZW1cclxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgY29uc29sZS5sb2coYPCfk6YgUHJvY2Vzc2FuZG8gYXJyYXkgY29tICR7ZGF0YS5sZW5ndGh9IGl0ZW5zYCk7XHJcbiAgICBjb25zdCBtZXNzYWdlczogc3RyaW5nW10gPSBbXTtcclxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coYPCflI0gUHJvY2Vzc2FuZG8gaXRlbSAke2luZGV4ICsgMX0vJHtkYXRhLmxlbmd0aH06YCwgaXRlbSk7XHJcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IGV4dHJhY3RSZXNwb25zZShpdGVtKTtcclxuICAgICAgY29uc29sZS5sb2coYPCfk50gSXRlbSAke2luZGV4ICsgMX0gZXh0cmHDrWRvOmAsIGV4dHJhY3RlZD8uc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgICBpZiAoZXh0cmFjdGVkICYmIGV4dHJhY3RlZC50cmltKCkpIHtcclxuICAgICAgICBtZXNzYWdlcy5wdXNoKGV4dHJhY3RlZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIEl0ZW0gJHtpbmRleCArIDF9IG7Do28gdGluaGEgY29udGXDumRvIHbDoWxpZG9gKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIFRvdGFsIGRlICR7bWVzc2FnZXMubGVuZ3RofSBtZW5zYWdlbnMgZXh0cmHDrWRhcyBkbyBhcnJheWApO1xyXG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xyXG4gIH1cclxuXHJcbiAgLy8gU2UgZm9yIG9iamV0bywgZXh0cmFpIGEgbWVuc2FnZW1cclxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgY29uc3QgZXh0cmFjdGVkID0gZXh0cmFjdFJlc3BvbnNlKGRhdGEpO1xyXG4gICAgY29uc29sZS5sb2coYPCfk50gT2JqZXRvIGV4dHJhw61kbzpgLCBleHRyYWN0ZWQ/LnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgIHJldHVybiBleHRyYWN0ZWQgJiYgZXh0cmFjdGVkLnRyaW0oKSA/IFtleHRyYWN0ZWRdIDogW107XHJcbiAgICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKFwi4pqg77iPIFRpcG8gZGUgZGFkb3MgbsOjbyByZWNvbmhlY2lkbywgcmV0b3JuYW5kbyBhcnJheSB2YXppb1wiKTtcclxuICByZXR1cm4gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnZpYSB1bWEgbWVuc2FnZW0gcGFyYSBvIHdlYmhvb2sgTjhOIGUgcmVjZWJlIG3Dumx0aXBsYXMgbWVuc2FnZW5zIHNlcGFyYWRhc1xyXG4gKiBTZSBhIHJlc3Bvc3RhIGluaWNpYWwgZm9yIFwid29ya2Zsb3cgaW5pY2lhZG9cIiwgZmF6IHBvbGxpbmcgYXTDqSByZWNlYmVyIGFzIG1lbnNhZ2Vuc1xyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEEgbWVuc2FnZW0gZG8gdXN1w6FyaW9cclxuICogQHBhcmFtIGFnZW50VHlwZSAtIFRpcG8gZG8gYWdlbnRlIElBIChzZHIsIGVjb21tZXJjZSwgYWdlbmRhbWVudG8pXHJcbiAqIEBwYXJhbSBvbk5ld01lc3NhZ2UgLSBDYWxsYmFjayBjaGFtYWRvIHBhcmEgY2FkYSBub3ZhIG1lbnNhZ2VtIHJlY2ViaWRhIGRhIElBXHJcbiAqIEBwYXJhbSBvblBvbGxpbmcgLSBDYWxsYmFjayBjaGFtYWRvIGR1cmFudGUgbyBwb2xsaW5nIChwYXJhIGFuaW1hw6fDo28pXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZE1lc3NhZ2VUb1dlYmhvb2soXHJcbiAgbWVzc2FnZTogc3RyaW5nLFxyXG4gIGFnZW50VHlwZTogQWdlbnRUeXBlLFxyXG4gIG9uTmV3TWVzc2FnZTogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCxcclxuICBvblBvbGxpbmc/OiAoaXNQb2xsaW5nOiBib29sZWFuKSA9PiB2b2lkXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBPYnTDqW0gb3UgY3JpYSBvIElEIMO6bmljbyBkYSBzZXNzw6NvXHJcbiAgICBjb25zdCBzZXNzaW9uSWQgPSBnZXRPckNyZWF0ZVNlc3Npb25JZCgpO1xyXG4gICAgXHJcbiAgICBjb25zdCBwYXlsb2FkOiBXZWJob29rTWVzc2FnZSA9IHtcclxuICAgICAgbWVzc2FnZTogbWVzc2FnZS50cmltKCksXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JZCxcclxuICAgICAgYWdlbnRUeXBlOiBhZ2VudFR5cGUsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvZyBwYXJhIGRlYnVnXHJcbiAgICBjb25zb2xlLmxvZyhcIkVudmlhbmRvIG1lbnNhZ2VtIHBhcmEgd2ViaG9vazpcIiwge1xyXG4gICAgICB1cmw6IFdFQkhPT0tfVVJMLFxyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChXRUJIT09LX1VSTCwge1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJSZXNwb3N0YSBkbyB3ZWJob29rOlwiLCB7XHJcbiAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxyXG4gICAgICBvazogcmVzcG9uc2Uub2ssXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiByZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gbmEgcmVzcG9zdGEgZG8gd2ViaG9vazpcIiwge1xyXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXHJcbiAgICAgICAgYm9keTogZXJyb3JUZXh0LFxyXG4gICAgICB9KTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvIEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVudGEgcGFyc2VhciBjb21vIEpTT04sIG1hcyB0YW1iw6ltIHN1cG9ydGEgdGV4dG8gc2ltcGxlc1xyXG4gICAgbGV0IGRhdGE6IFdlYmhvb2tSZXNwb25zZSB8IHN0cmluZztcclxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcclxuICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgZGF0YSA9IHRleHQ7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gcGFyc2VhciByZXNwb3N0YTpcIiwgcGFyc2VFcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm8gYW8gcHJvY2Vzc2FyIHJlc3Bvc3RhIGRvIHdlYmhvb2tcIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJEYWRvcyBwYXJzZWFkb3M6XCIsIGRhdGEpO1xyXG5cclxuICAgIC8vIEV4dHJhaSBhcyBtZW5zYWdlbnMgZG8gZm9ybWF0byByZXRvcm5hZG8gcGVsbyBOOE5cclxuICAgIGNvbnN0IG1lc3NhZ2VzID0gZXh0cmFjdE1lc3NhZ2VzKGRhdGEpO1xyXG4gICAgY29uc29sZS5sb2coXCJNZW5zYWdlbnMgZXh0cmHDrWRhczpcIiwgbWVzc2FnZXMpO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZmljYSBzZSBvIHdvcmtmbG93IGZvaSBpbmljaWFkbyAoaW5kaWNhIHF1ZSBtYWlzIG1lbnNhZ2VucyBwb2RlbSB2aXIpXHJcbiAgICBjb25zdCBpc1dvcmtmbG93U3RhcnRlZCA9IG1lc3NhZ2VzLnNvbWUobXNnID0+IGlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UobXNnKSk7XHJcbiAgICBjb25zdCB2YWxpZE1lc3NhZ2VzID0gbWVzc2FnZXMuZmlsdGVyKG1zZyA9PiAhaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZShtc2cpKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCfk4ogV29ya2Zsb3cgaW5pY2lhZG8/ICR7aXNXb3JrZmxvd1N0YXJ0ZWR9LCBNZW5zYWdlbnMgdsOhbGlkYXMgbmEgcmVzcG9zdGEgaW5pY2lhbDogJHt2YWxpZE1lc3NhZ2VzLmxlbmd0aH1gKTtcclxuICAgIFxyXG4gICAgLy8gUHJvY2Vzc2EgbWVuc2FnZW5zIGRhIHJlc3Bvc3RhIGluaWNpYWwgcHJpbWVpcm8gKHNlIGhvdXZlcilcclxuICAgIGlmICh2YWxpZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk6ggUHJvY2Vzc2FuZG8gJHt2YWxpZE1lc3NhZ2VzLmxlbmd0aH0gbWVuc2FnZW5zIGRhIHJlc3Bvc3RhIGluaWNpYWxgKTtcclxuICAgICAgdmFsaWRNZXNzYWdlcy5mb3JFYWNoKChtc2csIGluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk6QgRW52aWFuZG8gbWVuc2FnZW0gJHtpbmRleCArIDF9LyR7dmFsaWRNZXNzYWdlcy5sZW5ndGh9IGRhIHJlc3Bvc3RhIGluaWNpYWw6YCwgbXNnLnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgICAgICBvbk5ld01lc3NhZ2UobXNnKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENhbGxiYWNrIG9uTmV3TWVzc2FnZSBjaGFtYWRvIHBhcmEgbWVuc2FnZW0gJHtpbmRleCArIDF9YCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFRvZGFzIGFzICR7dmFsaWRNZXNzYWdlcy5sZW5ndGh9IG1lbnNhZ2VucyBkYSByZXNwb3N0YSBpbmljaWFsIGZvcmFtIGVudmlhZGFzYCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5lbmh1bWEgbWVuc2FnZW0gdsOhbGlkYSBlbmNvbnRyYWRhIG5hIHJlc3Bvc3RhIGluaWNpYWxgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU2VtcHJlIGZhemVtb3MgcG9sbGluZyBuYSBBUEkgaW50ZXJuYSBkZSBtZW5zYWdlbnMgcGFyYSB0cmF6ZXIgYXMgcmVzcG9zdGFzIHF1ZSBvIGZsdXhvIGVudmlvdSB2aWEgSFRUUCBSZXF1ZXN0MVxyXG4gICAgY29uc29sZS5sb2coXCLwn5SEIEluaWNpYW5kbyBwb2xsaW5nIG5hIEFQSSBpbnRlcm5hIC9hcGkvY2hhdC9tZXNzYWdlcyBwYXJhIGJ1c2NhciByZXNwb3N0YXMgZG8gZmx1eG9cIik7XHJcbiAgICBpZiAob25Qb2xsaW5nKSBvblBvbGxpbmcodHJ1ZSk7XHJcbiAgICBhd2FpdCBwb2xsQ2hhdE1lc3NhZ2VzKHNlc3Npb25JZCwgb25OZXdNZXNzYWdlLCB2YWxpZE1lc3NhZ2VzKTtcclxuICAgIGlmIChvblBvbGxpbmcpIG9uUG9sbGluZyhmYWxzZSk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGNvbXBsZXRvIGFvIGVudmlhciBtZW5zYWdlbSBwYXJhIHdlYmhvb2s6XCIsIHtcclxuICAgICAgZXJyb3IsXHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJFcnJvIGRlc2NvbmhlY2lkb1wiLFxyXG4gICAgICBzdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkLFxyXG4gICAgfSk7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYXogcG9sbGluZyBuYSBBUEkgaW50ZXJuYSAoL2FwaS9jaGF0L21lc3NhZ2VzKSBwYXJhIGJ1c2NhciBtZW5zYWdlbnMgcGVyc2lzdGlkYXMgcGVsbyBmbHV4b1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcG9sbENoYXRNZXNzYWdlcyhcclxuICBzZXNzaW9uSWQ6IHN0cmluZyxcclxuICBvbk5ld01lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgaW5pdGlhbE1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdLFxyXG4gIG1heEF0dGVtcHRzOiBudW1iZXIgPSA1MCwgICAgICAgICAgLy8gfjc1cyBubyBwaW9yIGNhc28gKDUwICogMS41cylcclxuICBpbnRlcnZhbE1zOiBudW1iZXIgPSAxNTAwLCAgICAgICAgIC8vIDEuNXMgZW50cmUgdGVudGF0aXZhc1xyXG4gIGVtcHR5QXR0ZW1wdHNUb1N0b3A6IG51bWJlciA9IDYsICAgLy8gcGFyYSBhcMOzcyA2IHRlbnRhdGl2YXMgdmF6aWFzIHNlZ3VpZGFzXHJcbiAgbWluQXR0ZW1wdHNCZWZvcmVTdG9wOiBudW1iZXIgPSA1ICAvLyBnYXJhbnRlIGFvIG1lbm9zIDUgdGVudGF0aXZhcyBhbnRlcyBkZSBwYXJhclxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBsZXQgY3Vyc29yID0gLTE7XHJcbiAgbGV0IGNvbnNlY3V0aXZlRW1wdHkgPSAwO1xyXG4gIGNvbnN0IHJlY2VpdmVkID0gbmV3IFNldDxzdHJpbmc+KGluaXRpYWxNZXNzYWdlcyk7XHJcblxyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xyXG4gICAgLy8gZXNwZXJhIGVudHJlIHRlbnRhdGl2YXMsIGV4Y2V0byBuYSBwcmltZWlyYVxyXG4gICAgaWYgKGF0dGVtcHQgPiAwKSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIGludGVydmFsTXMpKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB1cmwgPSBgJHtDSEFUX0FQSV9VUkx9P3Nlc3Npb25JZD0ke2VuY29kZVVSSUNvbXBvbmVudChzZXNzaW9uSWQpfSZjdXJzb3I9JHtjdXJzb3J9YDtcclxuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKHVybCwgeyBtZXRob2Q6IFwiR0VUXCIgfSk7XHJcbiAgICAgIGlmICghcmVzcC5vaykge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFBvbGxpbmcgY2hhdCBBUEkgc3RhdHVzICR7cmVzcC5zdGF0dXN9IG5hIHRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfWApO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcC5qc29uKCk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VzOiB7IHRleHQ/OiBzdHJpbmcgfVtdID0gZGF0YT8ubWVzc2FnZXMgPz8gW107XHJcbiAgICAgIGNvbnN0IGxhc3RJZHg6IG51bWJlciA9IHR5cGVvZiBkYXRhPy5sYXN0SWR4ID09PSBcIm51bWJlclwiID8gZGF0YS5sYXN0SWR4IDogY3Vyc29yO1xyXG5cclxuICAgICAgbGV0IG5ld0NvdW50ID0gMDtcclxuICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHR4dCA9IChtPy50ZXh0ID8/IFwiXCIpLnRyaW0oKTtcclxuICAgICAgICBpZiAodHh0ICYmICFyZWNlaXZlZC5oYXModHh0KSAmJiAhaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZSh0eHQpICYmIHR4dC50b0xvd2VyQ2FzZSgpICE9PSBcIm51bGxcIikge1xyXG4gICAgICAgICAgcmVjZWl2ZWQuYWRkKHR4dCk7XHJcbiAgICAgICAgICBuZXdDb3VudCsrO1xyXG4gICAgICAgICAgb25OZXdNZXNzYWdlKHR4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChuZXdDb3VudCA+IDApIHtcclxuICAgICAgICBjdXJzb3IgPSBsYXN0SWR4O1xyXG4gICAgICAgIGNvbnNlY3V0aXZlRW1wdHkgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNlY3V0aXZlRW1wdHkrKztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvbnNlY3V0aXZlRW1wdHkgPj0gZW1wdHlBdHRlbXB0c1RvU3RvcCAmJiBhdHRlbXB0ICsgMSA+PSBtaW5BdHRlbXB0c0JlZm9yZVN0b3ApIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEVycm8gYW8gZmF6ZXIgcG9sbGluZyBkYSBjaGF0IEFQSSBuYSB0ZW50YXRpdmEgJHthdHRlbXB0ICsgMX06YCwgZXJyKTtcclxuICAgICAgLy8gY29udGludWEgdGVudGFuZG9cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWkgYSByZXNwb3N0YSBkbyBmb3JtYXRvIHJldG9ybmFkbyBwZWxvIE44TlxyXG4gKiBTdXBvcnRhIGRpZmVyZW50ZXMgZm9ybWF0b3MgZGUgcmVzcG9zdGEsIGluY2x1aW5kbyBhcnJheXMgSlNPTlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlKGRhdGE6IFdlYmhvb2tSZXNwb25zZSB8IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgLy8gU2UgZm9yIHN0cmluZywgdGVudGEgcGFyc2VhciBjb21vIEpTT04gcHJpbWVpcm9cclxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIC8vIFRlbnRhIHBhcnNlYXIgY29tbyBKU09OXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAvLyBTZSBwYXJzZW91IGNvbSBzdWNlc3NvLCBwcm9jZXNzYSBvIG9iamV0by9hcnJheVxyXG4gICAgICByZXR1cm4gZXh0cmFjdFJlc3BvbnNlKHBhcnNlZCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gU2UgbsOjbyBmb3IgSlNPTiB2w6FsaWRvLCByZXRvcm5hIGEgc3RyaW5nIGNvbW8gZXN0w6FcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTZSBmb3IgdW0gYXJyYXksIHBlZ2EgbyBwcmltZWlybyBlbGVtZW50b1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgZmlyc3RJdGVtID0gZGF0YVswXTtcclxuICAgIC8vIFNlIG8gcHJpbWVpcm8gaXRlbSB0aXZlciBjYW1wbyBcIm91dHB1dFwiLCByZXRvcm5hIGVsZVxyXG4gICAgaWYgKGZpcnN0SXRlbSAmJiB0eXBlb2YgZmlyc3RJdGVtID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gZmlyc3RJdGVtKSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoZmlyc3RJdGVtLm91dHB1dCB8fCBcIlwiKTtcclxuICAgIH1cclxuICAgIC8vIFNlIG7Do28sIHRlbnRhIGV4dHJhaXIgZG8gcHJpbWVpcm8gaXRlbVxyXG4gICAgcmV0dXJuIGV4dHJhY3RSZXNwb25zZShmaXJzdEl0ZW0pO1xyXG4gIH1cclxuXHJcbiAgLy8gU2UgZm9yIG9iamV0bywgdGVudGEgZGlmZXJlbnRlcyBjYW1wb3MgY29tdW5zIGRlIHJlc3Bvc3RhXHJcbiAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIC8vIFByaW9yaXphIG8gY2FtcG8gXCJ0ZXh0XCIgKGZvcm1hdG8gY29tdW0gZG8gTjhOKVxyXG4gICAgaWYgKFwidGV4dFwiIGluIGRhdGEgJiYgZGF0YS50ZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIENhbXBvIFwidGV4dFwiIGVuY29udHJhZG86YCwgU3RyaW5nKGRhdGEudGV4dCkuc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGEudGV4dCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFByaW9yaXphIG8gY2FtcG8gXCJvdXRwdXRcIiBzZSBleGlzdGlyXHJcbiAgICBpZiAoXCJvdXRwdXRcIiBpbiBkYXRhICYmIGRhdGEub3V0cHV0KSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUZW50YSBvdXRyb3MgY2FtcG9zIGNvbXVuc1xyXG4gICAgaWYgKGRhdGEucmVzcG9uc2UpIHJldHVybiBTdHJpbmcoZGF0YS5yZXNwb25zZSk7XHJcbiAgICBpZiAoZGF0YS5tZXNzYWdlKSByZXR1cm4gU3RyaW5nKGRhdGEubWVzc2FnZSk7XHJcbiAgICBcclxuICAgIC8vIFRlbnRhIGNhbXBvcyBhbmluaGFkb3NcclxuICAgIGlmIChkYXRhLm91dHB1dCAmJiB0eXBlb2YgZGF0YS5vdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGRhdGEub3V0cHV0KSByZXR1cm4gU3RyaW5nKGRhdGEub3V0cHV0Lm1lc3NhZ2UpO1xyXG4gICAgICBpZiAoXCJyZXNwb25zZVwiIGluIGRhdGEub3V0cHV0KSByZXR1cm4gU3RyaW5nKGRhdGEub3V0cHV0LnJlc3BvbnNlKTtcclxuICAgICAgaWYgKFwidGV4dFwiIGluIGRhdGEub3V0cHV0KSByZXR1cm4gU3RyaW5nKGRhdGEub3V0cHV0LnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2UgbsOjbyBlbmNvbnRyYXIgbmVuaHVtIGNhbXBvIGNvbmhlY2lkbywgcmV0b3JuYSBvIEpTT04gc3RyaW5naWZpY2Fkb1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbIldFQkhPT0tfVVJMIiwiU0VTU0lPTl9JRF9TVE9SQUdFX0tFWSIsIkNIQVRfQVBJX1VSTCIsImdldE9yQ3JlYXRlU2Vzc2lvbklkIiwic3RvcmVkU2Vzc2lvbklkIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwibmV3U2Vzc2lvbklkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInNldEl0ZW0iLCJXT1JLRkxPV19TVEFSVEVEX01FU1NBR0VTIiwiaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZSIsInJlc3BvbnNlIiwibG93ZXJSZXNwb25zZSIsInRvTG93ZXJDYXNlIiwic29tZSIsIm1zZyIsImluY2x1ZGVzIiwicG9sbEZvck1lc3NhZ2VzIiwic2Vzc2lvbklkIiwib25OZXdNZXNzYWdlIiwiaW5pdGlhbE1lc3NhZ2VzIiwibWF4QXR0ZW1wdHMiLCJpbnRlcnZhbE1zIiwiZW1wdHlBdHRlbXB0c1RvU3RvcCIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJyZWNlaXZlZE1lc3NhZ2VzIiwiU2V0IiwiY29uc2VjdXRpdmVFbXB0eUF0dGVtcHRzIiwiYXR0ZW1wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY2hlY2tTdGF0dXMiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsIm9rIiwiY29udGVudFR5cGUiLCJnZXQiLCJkYXRhIiwianNvbiIsInRleHQiLCJtZXNzYWdlcyIsImV4dHJhY3RNZXNzYWdlcyIsIm5ld01lc3NhZ2VzQ291bnQiLCJmb3JFYWNoIiwidHJpbW1lZE1zZyIsInRyaW0iLCJoYXMiLCJhZGQiLCJzaXplIiwid2FybiIsInN0YXR1cyIsImVycm9yIiwiaGFzTWVzc2FnZXMiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZWQiLCJwYXJzZSIsIml0ZW0iLCJpbmRleCIsImV4dHJhY3RlZCIsImV4dHJhY3RSZXNwb25zZSIsInB1c2giLCJzZW5kTWVzc2FnZVRvV2ViaG9vayIsIm1lc3NhZ2UiLCJhZ2VudFR5cGUiLCJvblBvbGxpbmciLCJwYXlsb2FkIiwidXJsIiwic3RhdHVzVGV4dCIsImVycm9yVGV4dCIsImNhdGNoIiwiRXJyb3IiLCJwYXJzZUVycm9yIiwiaXNXb3JrZmxvd1N0YXJ0ZWQiLCJ2YWxpZE1lc3NhZ2VzIiwiZmlsdGVyIiwicG9sbENoYXRNZXNzYWdlcyIsInN0YWNrIiwidW5kZWZpbmVkIiwibWluQXR0ZW1wdHNCZWZvcmVTdG9wIiwiY3Vyc29yIiwiY29uc2VjdXRpdmVFbXB0eSIsInJlY2VpdmVkIiwiciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3AiLCJsYXN0SWR4IiwibmV3Q291bnQiLCJtIiwidHh0IiwiZXJyIiwiZmlyc3RJdGVtIiwiU3RyaW5nIiwib3V0cHV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/webhookService.ts\n"));

/***/ })

});