"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Demo_tsx",{

/***/ "(app-pages-browser)/./src/services/webhookService.ts":
/*!****************************************!*\
  !*** ./src/services/webhookService.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSessionId: function() { return /* binding */ createSessionId; },\n/* harmony export */   isWorkflowStartedResponse: function() { return /* binding */ isWorkflowStartedResponse; },\n/* harmony export */   sendMessageToWebhook: function() { return /* binding */ sendMessageToWebhook; }\n/* harmony export */ });\n/**\r\n * Serviço para comunicação com o webhook N8N\r\n */ const WEBHOOK_URL = \"https://webhook.agentemwd.com/webhook/9de471bd-4296-4cc8-bc40-f2ea1d19f6dd\";\nconst CHAT_API_URL = \"/api/chat/messages\";\n/**\r\n * Gera um ID único para a sessão ou recupera o existente do sessionStorage\r\n * O ID é único por sessão do navegador (recarrega quando a página é recarregada)\r\n * @returns ID único da sessão\r\n */ function createSessionId() {\n    return \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 15));\n}\n// Mensagens que indicam que o workflow foi iniciado mas ainda não há resposta\nconst WORKFLOW_STARTED_MESSAGES = [\n    \"workflow foi iniciado\",\n    \"workflow iniciado\",\n    \"workflow started\",\n    \"processando\",\n    \"processando sua mensagem\",\n    \"aguarde\",\n    \"workflow was started\"\n];\n/**\r\n * Verifica se a resposta indica que o workflow foi iniciado mas ainda não há resposta final\r\n */ function isWorkflowStartedResponse(response) {\n    const lowerResponse = response.toLowerCase();\n    return WORKFLOW_STARTED_MESSAGES.some((msg)=>lowerResponse.includes(msg));\n}\n/**\r\n * Faz polling para verificar se há mensagens disponíveis\r\n * IMPORTANTE: Apenas verifica status, NÃO inicia novas execuções\r\n * @param sessionId - ID da sessão\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida\r\n * @param maxAttempts - Número máximo de tentativas (padrão: 30 = 60 segundos)\r\n * @param intervalMs - Intervalo entre tentativas em ms (padrão: 2000 = 2 segundos)\r\n * @param emptyAttemptsToStop - Número de tentativas vazias consecutivas para parar (padrão: 2)\r\n * @returns true se recebeu mensagens, false se timeout\r\n */ async function pollForMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 30, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;\n    console.log(\"\\uD83D\\uDD04 Iniciando polling APENAS para verificar status. SessionId: \".concat(sessionId, \", m\\xe1ximo \").concat(maxAttempts, \" tentativas\"));\n    console.log(\"\\uD83D\\uDCCB Mensagens j\\xe1 recebidas na primeira resposta: \".concat(initialMessages.length));\n    // Usa normalização para comparação de mensagens\n    const receivedMessages = new Set(initialMessages.map(normalizeMessage)); // Inclui mensagens já recebidas para evitar duplicatas\n    let consecutiveEmptyAttempts = 0; // Contador de tentativas consecutivas sem novas mensagens\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // Aguarda antes de fazer a próxima tentativa (exceto na primeira)\n        if (attempt > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, intervalMs));\n        }\n        try {\n            // IMPORTANTE: Apenas verifica status, NÃO envia mensagem nem agentType\n            // Isso evita iniciar novas execuções do workflow\n            const response = await fetch(WEBHOOK_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    sessionId: sessionId,\n                    checkStatus: true,\n                    timestamp: new Date().toISOString()\n                })\n            });\n            if (response.ok) {\n                const contentType = response.headers.get(\"content-type\");\n                let data;\n                if (contentType && contentType.includes(\"application/json\")) {\n                    data = await response.json();\n                } else {\n                    const text = await response.text();\n                    data = text;\n                }\n                // Processa múltiplas mensagens se vierem em array\n                const messages = extractMessages(data);\n                console.log(\"\\uD83D\\uDCE6 Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": \").concat(messages.length, \" mensagens extra\\xeddas\"));\n                let newMessagesCount = 0;\n                // Chama o callback para cada nova mensagem\n                messages.forEach((msg)=>{\n                    const trimmedMsg = msg.trim();\n                    if (trimmedMsg.length > 0 && !isWorkflowStartedResponse(trimmedMsg) && trimmedMsg.toLowerCase() !== \"null\" && trimmedMsg.toLowerCase() !== \"undefined\" && !receivedMessages.has(trimmedMsg)) {\n                        receivedMessages.add(trimmedMsg);\n                        newMessagesCount++;\n                        console.log(\"✅ Nova mensagem \".concat(newMessagesCount, \" recebida na tentativa \").concat(attempt + 1, \":\"), trimmedMsg.substring(0, 100));\n                        onNewMessage(trimmedMsg);\n                    }\n                });\n                // Se recebeu novas mensagens, reseta o contador de tentativas vazias\n                if (newMessagesCount > 0) {\n                    consecutiveEmptyAttempts = 0;\n                    console.log(\"\\uD83D\\uDCCA Total de mensagens recebidas at\\xe9 agora: \".concat(receivedMessages.size));\n                } else {\n                    consecutiveEmptyAttempts++;\n                    console.log(\"⏳ Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": Sem novas mensagens (\").concat(consecutiveEmptyAttempts, \"/\").concat(emptyAttemptsToStop, \" tentativas vazias consecutivas)\"));\n                }\n                // Para o polling se não houver novas mensagens por várias tentativas consecutivas\n                if (consecutiveEmptyAttempts >= emptyAttemptsToStop) {\n                    if (receivedMessages.size > 0) {\n                        console.log(\"⏹️ Parando polling: \".concat(emptyAttemptsToStop, \" tentativas consecutivas sem novas mensagens. Total: \").concat(receivedMessages.size, \" mensagens recebidas\"));\n                        break;\n                    } else if (attempt >= 5) {\n                        // Se não recebeu nenhuma mensagem após 5 tentativas, também para\n                        console.log(\"⏹️ Parando polling: Nenhuma mensagem recebida ap\\xf3s \".concat(attempt + 1, \" tentativas\"));\n                        break;\n                    }\n                }\n            } else {\n                console.warn(\"⚠️ Tentativa \".concat(attempt + 1, \": Status \").concat(response.status));\n            }\n        } catch (error) {\n            console.warn(\"⚠️ Erro na tentativa \".concat(attempt + 1, \" de polling:\"), error);\n        // Continua tentando mesmo com erro\n        }\n    }\n    const hasMessages = receivedMessages.size > 0;\n    if (!hasMessages) {\n        console.warn(\"⏱️ Timeout: N\\xe3o foi poss\\xedvel obter mensagens ap\\xf3s \".concat(maxAttempts, \" tentativas\"));\n    } else {\n        console.log(\"✅ Polling finalizado. Total de \".concat(receivedMessages.size, \" mensagens recebidas\"));\n    }\n    return hasMessages;\n}\n/**\r\n * Extrai múltiplas mensagens do formato retornado pelo N8N\r\n * Suporta arrays de mensagens ou mensagem única\r\n */ function extractMessages(data) {\n    console.log(\"\\uD83D\\uDD0D extractMessages chamado com:\", typeof data, Array.isArray(data) ? \"array[\".concat(data.length, \"]\") : data);\n    // Se for string, tenta parsear como JSON\n    if (typeof data === \"string\") {\n        try {\n            const parsed = JSON.parse(data);\n            return extractMessages(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna como array com uma mensagem\n            return data.trim() ? [\n                data\n            ] : [];\n        }\n    }\n    // Se for um array, processa cada item\n    if (Array.isArray(data)) {\n        console.log(\"\\uD83D\\uDCE6 Processando array com \".concat(data.length, \" itens\"));\n        const messages = [];\n        data.forEach((item, index)=>{\n            console.log(\"\\uD83D\\uDD0D Processando item \".concat(index + 1, \"/\").concat(data.length, \":\"), item);\n            const extracted = extractResponse(item);\n            console.log(\"\\uD83D\\uDCDD Item \".concat(index + 1, \" extra\\xeddo:\"), extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n            if (extracted && extracted.trim()) {\n                messages.push(extracted);\n            } else {\n                console.log(\"⚠️ Item \".concat(index + 1, \" n\\xe3o tinha conte\\xfado v\\xe1lido\"));\n            }\n        });\n        console.log(\"✅ Total de \".concat(messages.length, \" mensagens extra\\xeddas do array\"));\n        return messages;\n    }\n    // Se for objeto, extrai a mensagem\n    if (data && typeof data === \"object\") {\n        const extracted = extractResponse(data);\n        console.log(\"\\uD83D\\uDCDD Objeto extra\\xeddo:\", extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n        return extracted && extracted.trim() ? [\n            extracted\n        ] : [];\n    }\n    console.log(\"⚠️ Tipo de dados n\\xe3o reconhecido, retornando array vazio\");\n    return [];\n}\n/**\r\n * Envia uma mensagem para o webhook N8N e recebe múltiplas mensagens separadas\r\n * Se a resposta inicial for \"workflow iniciado\", faz polling até receber as mensagens\r\n * @param message - A mensagem do usuário\r\n * @param agentType - Tipo do agente IA (sdr, ecommerce, agendamento)\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida da IA\r\n * @param onPolling - Callback chamado durante o polling (para animação)\r\n */ async function sendMessageToWebhook(message, agentType, sessionId, onNewMessage, onPolling) {\n    try {\n        if (!sessionId) {\n            throw new Error(\"sessionId \\xe9 obrigat\\xf3rio para enviar mensagens\");\n        }\n        const payload = {\n            message: message.trim(),\n            timestamp: new Date().toISOString(),\n            sessionId: sessionId,\n            agentType: agentType\n        };\n        // Log para debug\n        console.log(\"Enviando mensagem para webhook:\", {\n            url: WEBHOOK_URL,\n            method: \"POST\",\n            payload: payload\n        });\n        const response = await fetch(WEBHOOK_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload)\n        });\n        console.log(\"Resposta do webhook:\", {\n            status: response.status,\n            statusText: response.statusText,\n            ok: response.ok\n        });\n        if (!response.ok) {\n            const errorText = await response.text().catch(()=>response.statusText);\n            console.error(\"Erro na resposta do webhook:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Erro HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Tenta parsear como JSON, mas também suporta texto simples\n        let data;\n        const contentType = response.headers.get(\"content-type\");\n        try {\n            if (contentType && contentType.includes(\"application/json\")) {\n                data = await response.json();\n            } else {\n                const text = await response.text();\n                data = text;\n            }\n        } catch (parseError) {\n            console.error(\"Erro ao parsear resposta:\", parseError);\n            throw new Error(\"Erro ao processar resposta do webhook\");\n        }\n        console.log(\"Dados parseados:\", data);\n        // Extrai as mensagens do formato retornado pelo N8N\n        const messages = extractMessages(data);\n        console.log(\"Mensagens extra\\xeddas:\", messages);\n        // Verifica se o workflow foi iniciado (indica que mais mensagens podem vir)\n        const isWorkflowStarted = messages.some((msg)=>isWorkflowStartedResponse(msg));\n        const validMessages = messages.filter((msg)=>!isWorkflowStartedResponse(msg));\n        console.log(\"\\uD83D\\uDCCA Workflow iniciado? \".concat(isWorkflowStarted, \", Mensagens v\\xe1lidas na resposta inicial: \").concat(validMessages.length));\n        // Processa mensagens da resposta inicial primeiro (se houver)\n        if (validMessages.length > 0) {\n            console.log(\"\\uD83D\\uDCE8 Processando \".concat(validMessages.length, \" mensagens da resposta inicial\"));\n            validMessages.forEach((msg, index)=>{\n                console.log(\"\\uD83D\\uDCE4 Enviando mensagem \".concat(index + 1, \"/\").concat(validMessages.length, \" da resposta inicial:\"), msg.substring(0, 100));\n                onNewMessage(msg);\n                console.log(\"✅ Callback onNewMessage chamado para mensagem \".concat(index + 1));\n            });\n            console.log(\"✅ Todas as \".concat(validMessages.length, \" mensagens da resposta inicial foram enviadas\"));\n        } else {\n            console.log(\"⚠️ Nenhuma mensagem v\\xe1lida encontrada na resposta inicial\");\n        }\n        // Sempre fazemos polling na API interna de mensagens para trazer as respostas que o fluxo enviou via HTTP Request1\n        console.log(\"\\uD83D\\uDD04 Iniciando polling na API interna /api/chat/messages para buscar respostas do fluxo\");\n        if (onPolling) onPolling(true);\n        await pollChatMessages(sessionId, onNewMessage, validMessages);\n        if (onPolling) onPolling(false);\n    } catch (error) {\n        console.error(\"Erro completo ao enviar mensagem para webhook:\", {\n            error,\n            message: error instanceof Error ? error.message : \"Erro desconhecido\",\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        throw error;\n    }\n}\n/**\r\n * Faz polling na API interna (/api/chat/messages) para buscar mensagens persistidas pelo fluxo\r\n */ // Normaliza mensagem para comparação (remove espaços extras, quebras de linha, etc)\nfunction normalizeMessage(msg) {\n    return msg.trim().replace(/\\s+/g, \" \").toLowerCase();\n}\nasync function pollChatMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 80, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 8, minAttemptsBeforeStop = arguments.length > 6 && arguments[6] !== void 0 // garante ao menos 6 tentativas antes de parar\n     ? arguments[6] : 6;\n    let cursor = -1;\n    let consecutiveEmpty = 0;\n    // Usa normalização para comparação de mensagens\n    const received = new Set(initialMessages.map(normalizeMessage));\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // espera entre tentativas, exceto na primeira\n        if (attempt > 0) {\n            await new Promise((r)=>setTimeout(r, intervalMs));\n        }\n        try {\n            const url = \"\".concat(CHAT_API_URL, \"?sessionId=\").concat(encodeURIComponent(sessionId), \"&cursor=\").concat(cursor);\n            const resp = await fetch(url, {\n                method: \"GET\"\n            });\n            if (!resp.ok) {\n                console.warn(\"⚠️ Polling chat API status \".concat(resp.status, \" na tentativa \").concat(attempt + 1));\n                continue;\n            }\n            const data = await resp.json();\n            var _data_messages;\n            const messages = (_data_messages = data === null || data === void 0 ? void 0 : data.messages) !== null && _data_messages !== void 0 ? _data_messages : [];\n            const lastIdx = typeof (data === null || data === void 0 ? void 0 : data.lastIdx) === \"number\" ? data.lastIdx : cursor;\n            let newCount = 0;\n            messages.forEach((m)=>{\n                var _m_text;\n                const txt = ((_m_text = m === null || m === void 0 ? void 0 : m.text) !== null && _m_text !== void 0 ? _m_text : \"\").trim();\n                if (!txt || txt.toLowerCase() === \"null\" || isWorkflowStartedResponse(txt)) {\n                    return;\n                }\n                const normalized = normalizeMessage(txt);\n                if (!received.has(normalized)) {\n                    received.add(normalized);\n                    newCount++;\n                    console.log(\"✅ Nova mensagem do polling (\".concat(newCount, \"):\"), txt.substring(0, 100));\n                    onNewMessage(txt);\n                } else {\n                    console.log(\"⚠️ Mensagem duplicada ignorada no polling:\", txt.substring(0, 50));\n                }\n            });\n            if (newCount > 0) {\n                cursor = lastIdx;\n                consecutiveEmpty = 0;\n            } else {\n                consecutiveEmpty++;\n            }\n            if (consecutiveEmpty >= emptyAttemptsToStop && attempt + 1 >= minAttemptsBeforeStop) {\n                break;\n            }\n        } catch (err) {\n            console.warn(\"⚠️ Erro ao fazer polling da chat API na tentativa \".concat(attempt + 1, \":\"), err);\n        // continua tentando\n        }\n    }\n}\n/**\r\n * Extrai a resposta do formato retornado pelo N8N\r\n * Suporta diferentes formatos de resposta, incluindo arrays JSON\r\n */ function extractResponse(data) {\n    // Se for string, tenta parsear como JSON primeiro\n    if (typeof data === \"string\") {\n        // Tenta parsear como JSON\n        try {\n            const parsed = JSON.parse(data);\n            // Se parseou com sucesso, processa o objeto/array\n            return extractResponse(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna a string como está\n            return data;\n        }\n    }\n    // Se for um array, pega o primeiro elemento\n    if (Array.isArray(data) && data.length > 0) {\n        const firstItem = data[0];\n        // Se o primeiro item tiver campo \"output\", retorna ele\n        if (firstItem && typeof firstItem === \"object\" && \"output\" in firstItem) {\n            return String(firstItem.output || \"\");\n        }\n        // Se não, tenta extrair do primeiro item\n        return extractResponse(firstItem);\n    }\n    // Se for objeto, tenta diferentes campos comuns de resposta\n    if (data && typeof data === \"object\") {\n        // Prioriza o campo \"text\" (formato comum do N8N)\n        if (\"text\" in data && data.text) {\n            console.log('\\uD83D\\uDCDD Campo \"text\" encontrado:', String(data.text).substring(0, 100));\n            return String(data.text);\n        }\n        // Prioriza o campo \"output\" se existir\n        if (\"output\" in data && data.output) {\n            return String(data.output);\n        }\n        // Tenta outros campos comuns\n        if (data.response) return String(data.response);\n        if (data.message) return String(data.message);\n        // Tenta campos aninhados\n        if (data.output && typeof data.output === \"object\") {\n            if (\"message\" in data.output) return String(data.output.message);\n            if (\"response\" in data.output) return String(data.output.response);\n            if (\"text\" in data.output) return String(data.output.text);\n        }\n    }\n    // Se não encontrar nenhum campo conhecido, retorna o JSON stringificado\n    return JSON.stringify(data);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWJob29rU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Q0FFQyxHQUVELE1BQU1BLGNBQWM7QUFDcEIsTUFBTUMsZUFBZTtBQVdyQjs7OztDQUlDLEdBQ00sU0FBU0M7SUFDZCxPQUFPLFdBQXlCQyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBK0MsT0FBNUNGLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHO0FBQzFFO0FBYUEsOEVBQThFO0FBQzlFLE1BQU1DLDRCQUE0QjtJQUNoQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7O0NBRUMsR0FDTSxTQUFTQywwQkFBMEJDLFFBQWdCO0lBQ3hELE1BQU1DLGdCQUFnQkQsU0FBU0UsV0FBVztJQUMxQyxPQUFPSiwwQkFBMEJLLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0gsY0FBY0ksUUFBUSxDQUFDRDtBQUN0RTtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELGVBQWVFLGdCQUNiQyxTQUFpQixFQUNqQkMsWUFBdUM7UUFDdkNDLGtCQUFBQSxpRUFBNEIsRUFBRSxFQUM5QkMsY0FBQUEsaUVBQXNCLElBQ3RCQyxhQUFBQSxpRUFBcUIsTUFDckJDLHNCQUFBQSxpRUFBOEI7SUFFOUJDLFFBQVFDLEdBQUcsQ0FBQywyRUFBc0ZKLE9BQXJCSCxXQUFVLGdCQUF1QixPQUFaRyxhQUFZO0lBQzlHRyxRQUFRQyxHQUFHLENBQUMsZ0VBQTBFLE9BQXZCTCxnQkFBZ0JNLE1BQU07SUFFckYsZ0RBQWdEO0lBQ2hELE1BQU1DLG1CQUFtQixJQUFJQyxJQUFZUixnQkFBZ0JTLEdBQUcsQ0FBQ0Msb0JBQW9CLHVEQUF1RDtJQUN4SSxJQUFJQywyQkFBMkIsR0FBRywwREFBMEQ7SUFFNUYsSUFBSyxJQUFJQyxVQUFVLEdBQUdBLFVBQVVYLGFBQWFXLFVBQVc7UUFDdEQsa0VBQWtFO1FBQ2xFLElB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T0FBT3pELEtBQUswRCxNQUFNLENBQUMvRixRQUFRO1lBQ2pFLElBQUksVUFBVXFDLEtBQUswRCxNQUFNLEVBQUUsT0FBT0QsT0FBT3pELEtBQUswRCxNQUFNLENBQUN4RCxJQUFJO1FBQzNEO0lBQ0Y7SUFFQSx3RUFBd0U7SUFDeEUsT0FBT1YsS0FBS0MsU0FBUyxDQUFDTztBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvd2ViaG9va1NlcnZpY2UudHM/NWNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU2VydmnDp28gcGFyYSBjb211bmljYcOnw6NvIGNvbSBvIHdlYmhvb2sgTjhOXHJcbiAqL1xyXG5cclxuY29uc3QgV0VCSE9PS19VUkwgPSBcImh0dHBzOi8vd2ViaG9vay5hZ2VudGVtd2QuY29tL3dlYmhvb2svOWRlNDcxYmQtNDI5Ni00Y2M4LWJjNDAtZjJlYTFkMTlmNmRkXCI7XHJcbmNvbnN0IENIQVRfQVBJX1VSTCA9IFwiL2FwaS9jaGF0L21lc3NhZ2VzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBBZ2VudFR5cGUgPSBcInNkclwiIHwgXCJlY29tbWVyY2VcIiB8IFwiYWdlbmRhbWVudG9cIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va01lc3NhZ2Uge1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBzZXNzaW9uSWQ6IHN0cmluZztcclxuICBhZ2VudFR5cGU6IEFnZW50VHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlcmEgdW0gSUQgw7puaWNvIHBhcmEgYSBzZXNzw6NvIG91IHJlY3VwZXJhIG8gZXhpc3RlbnRlIGRvIHNlc3Npb25TdG9yYWdlXHJcbiAqIE8gSUQgw6kgw7puaWNvIHBvciBzZXNzw6NvIGRvIG5hdmVnYWRvciAocmVjYXJyZWdhIHF1YW5kbyBhIHDDoWdpbmEgw6kgcmVjYXJyZWdhZGEpXHJcbiAqIEByZXR1cm5zIElEIMO6bmljbyBkYSBzZXNzw6NvXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBzZXNzaW9uXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va1Jlc3BvbnNlIHtcclxuICByZXNwb25zZT86IHN0cmluZztcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG4gIHRleHQ/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIG91dHB1dD86IHtcclxuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgICByZXNwb25zZT86IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG4vLyBNZW5zYWdlbnMgcXVlIGluZGljYW0gcXVlIG8gd29ya2Zsb3cgZm9pIGluaWNpYWRvIG1hcyBhaW5kYSBuw6NvIGjDoSByZXNwb3N0YVxyXG5jb25zdCBXT1JLRkxPV19TVEFSVEVEX01FU1NBR0VTID0gW1xyXG4gIFwid29ya2Zsb3cgZm9pIGluaWNpYWRvXCIsXHJcbiAgXCJ3b3JrZmxvdyBpbmljaWFkb1wiLFxyXG4gIFwid29ya2Zsb3cgc3RhcnRlZFwiLFxyXG4gIFwicHJvY2Vzc2FuZG9cIixcclxuICBcInByb2Nlc3NhbmRvIHN1YSBtZW5zYWdlbVwiLFxyXG4gIFwiYWd1YXJkZVwiLFxyXG4gIFwid29ya2Zsb3cgd2FzIHN0YXJ0ZWRcIixcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBWZXJpZmljYSBzZSBhIHJlc3Bvc3RhIGluZGljYSBxdWUgbyB3b3JrZmxvdyBmb2kgaW5pY2lhZG8gbWFzIGFpbmRhIG7Do28gaMOhIHJlc3Bvc3RhIGZpbmFsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZShyZXNwb25zZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgbG93ZXJSZXNwb25zZSA9IHJlc3BvbnNlLnRvTG93ZXJDYXNlKCk7XHJcbiAgcmV0dXJuIFdPUktGTE9XX1NUQVJURURfTUVTU0FHRVMuc29tZShtc2cgPT4gbG93ZXJSZXNwb25zZS5pbmNsdWRlcyhtc2cpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZheiBwb2xsaW5nIHBhcmEgdmVyaWZpY2FyIHNlIGjDoSBtZW5zYWdlbnMgZGlzcG9uw612ZWlzXHJcbiAqIElNUE9SVEFOVEU6IEFwZW5hcyB2ZXJpZmljYSBzdGF0dXMsIE7Dg08gaW5pY2lhIG5vdmFzIGV4ZWN1w6fDtWVzXHJcbiAqIEBwYXJhbSBzZXNzaW9uSWQgLSBJRCBkYSBzZXNzw6NvXHJcbiAqIEBwYXJhbSBvbk5ld01lc3NhZ2UgLSBDYWxsYmFjayBjaGFtYWRvIHBhcmEgY2FkYSBub3ZhIG1lbnNhZ2VtIHJlY2ViaWRhXHJcbiAqIEBwYXJhbSBtYXhBdHRlbXB0cyAtIE7Dum1lcm8gbcOheGltbyBkZSB0ZW50YXRpdmFzIChwYWRyw6NvOiAzMCA9IDYwIHNlZ3VuZG9zKVxyXG4gKiBAcGFyYW0gaW50ZXJ2YWxNcyAtIEludGVydmFsbyBlbnRyZSB0ZW50YXRpdmFzIGVtIG1zIChwYWRyw6NvOiAyMDAwID0gMiBzZWd1bmRvcylcclxuICogQHBhcmFtIGVtcHR5QXR0ZW1wdHNUb1N0b3AgLSBOw7ptZXJvIGRlIHRlbnRhdGl2YXMgdmF6aWFzIGNvbnNlY3V0aXZhcyBwYXJhIHBhcmFyIChwYWRyw6NvOiAyKVxyXG4gKiBAcmV0dXJucyB0cnVlIHNlIHJlY2ViZXUgbWVuc2FnZW5zLCBmYWxzZSBzZSB0aW1lb3V0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBwb2xsRm9yTWVzc2FnZXMoXHJcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXHJcbiAgb25OZXdNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxyXG4gIGluaXRpYWxNZXNzYWdlczogc3RyaW5nW10gPSBbXSwgLy8gTWVuc2FnZW5zIGrDoSByZWNlYmlkYXMgbmEgcHJpbWVpcmEgcmVzcG9zdGFcclxuICBtYXhBdHRlbXB0czogbnVtYmVyID0gMzAsXHJcbiAgaW50ZXJ2YWxNczogbnVtYmVyID0gMjAwMCxcclxuICBlbXB0eUF0dGVtcHRzVG9TdG9wOiBudW1iZXIgPSAyXHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGNvbnNvbGUubG9nKGDwn5SEIEluaWNpYW5kbyBwb2xsaW5nIEFQRU5BUyBwYXJhIHZlcmlmaWNhciBzdGF0dXMuIFNlc3Npb25JZDogJHtzZXNzaW9uSWR9LCBtw6F4aW1vICR7bWF4QXR0ZW1wdHN9IHRlbnRhdGl2YXNgKTtcclxuICBjb25zb2xlLmxvZyhg8J+TiyBNZW5zYWdlbnMgasOhIHJlY2ViaWRhcyBuYSBwcmltZWlyYSByZXNwb3N0YTogJHtpbml0aWFsTWVzc2FnZXMubGVuZ3RofWApO1xyXG4gIFxyXG4gIC8vIFVzYSBub3JtYWxpemHDp8OjbyBwYXJhIGNvbXBhcmHDp8OjbyBkZSBtZW5zYWdlbnNcclxuICBjb25zdCByZWNlaXZlZE1lc3NhZ2VzID0gbmV3IFNldDxzdHJpbmc+KGluaXRpYWxNZXNzYWdlcy5tYXAobm9ybWFsaXplTWVzc2FnZSkpOyAvLyBJbmNsdWkgbWVuc2FnZW5zIGrDoSByZWNlYmlkYXMgcGFyYSBldml0YXIgZHVwbGljYXRhc1xyXG4gIGxldCBjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMgPSAwOyAvLyBDb250YWRvciBkZSB0ZW50YXRpdmFzIGNvbnNlY3V0aXZhcyBzZW0gbm92YXMgbWVuc2FnZW5zXHJcbiAgXHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XHJcbiAgICAvLyBBZ3VhcmRhIGFudGVzIGRlIGZhemVyIGEgcHLDs3hpbWEgdGVudGF0aXZhIChleGNldG8gbmEgcHJpbWVpcmEpXHJcbiAgICBpZiAoYXR0ZW1wdCA+IDApIHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsTXMpKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJTVBPUlRBTlRFOiBBcGVuYXMgdmVyaWZpY2Egc3RhdHVzLCBOw4NPIGVudmlhIG1lbnNhZ2VtIG5lbSBhZ2VudFR5cGVcclxuICAgICAgLy8gSXNzbyBldml0YSBpbmljaWFyIG5vdmFzIGV4ZWN1w6fDtWVzIGRvIHdvcmtmbG93XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goV0VCSE9PS19VUkwsIHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXHJcbiAgICAgICAgICBjaGVja1N0YXR1czogdHJ1ZSwgLy8gSW5kaWNhIHF1ZSDDqSBBUEVOQVMgdW1hIHZlcmlmaWNhw6fDo28gZGUgc3RhdHVzXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xyXG4gICAgICAgIGxldCBkYXRhOiBXZWJob29rUmVzcG9uc2UgfCBzdHJpbmcgfCBhbnk7XHJcblxyXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcclxuICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICBkYXRhID0gdGV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByb2Nlc3NhIG3Dumx0aXBsYXMgbWVuc2FnZW5zIHNlIHZpZXJlbSBlbSBhcnJheVxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZXh0cmFjdE1lc3NhZ2VzKGRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OmIFRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfS8ke21heEF0dGVtcHRzfTogJHttZXNzYWdlcy5sZW5ndGh9IG1lbnNhZ2VucyBleHRyYcOtZGFzYCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG5ld01lc3NhZ2VzQ291bnQgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoYW1hIG8gY2FsbGJhY2sgcGFyYSBjYWRhIG5vdmEgbWVuc2FnZW1cclxuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtc2c6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdHJpbW1lZE1zZyA9IG1zZy50cmltKCk7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRyaW1tZWRNc2cubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICAhaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZSh0cmltbWVkTXNnKSAmJlxyXG4gICAgICAgICAgICB0cmltbWVkTXNnLnRvTG93ZXJDYXNlKCkgIT09IFwibnVsbFwiICYmXHJcbiAgICAgICAgICAgIHRyaW1tZWRNc2cudG9Mb3dlckNhc2UoKSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAhcmVjZWl2ZWRNZXNzYWdlcy5oYXModHJpbW1lZE1zZylcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLmFkZCh0cmltbWVkTXNnKTtcclxuICAgICAgICAgICAgbmV3TWVzc2FnZXNDb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIE5vdmEgbWVuc2FnZW0gJHtuZXdNZXNzYWdlc0NvdW50fSByZWNlYmlkYSBuYSB0ZW50YXRpdmEgJHthdHRlbXB0ICsgMX06YCwgdHJpbW1lZE1zZy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgICAgICAgIG9uTmV3TWVzc2FnZSh0cmltbWVkTXNnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZSByZWNlYmV1IG5vdmFzIG1lbnNhZ2VucywgcmVzZXRhIG8gY29udGFkb3IgZGUgdGVudGF0aXZhcyB2YXppYXNcclxuICAgICAgICBpZiAobmV3TWVzc2FnZXNDb3VudCA+IDApIHtcclxuICAgICAgICAgIGNvbnNlY3V0aXZlRW1wdHlBdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBUb3RhbCBkZSBtZW5zYWdlbnMgcmVjZWJpZGFzIGF0w6kgYWdvcmE6ICR7cmVjZWl2ZWRNZXNzYWdlcy5zaXplfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMrKztcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7MgVGVudGF0aXZhICR7YXR0ZW1wdCArIDF9LyR7bWF4QXR0ZW1wdHN9OiBTZW0gbm92YXMgbWVuc2FnZW5zICgke2NvbnNlY3V0aXZlRW1wdHlBdHRlbXB0c30vJHtlbXB0eUF0dGVtcHRzVG9TdG9wfSB0ZW50YXRpdmFzIHZhemlhcyBjb25zZWN1dGl2YXMpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFBhcmEgbyBwb2xsaW5nIHNlIG7Do28gaG91dmVyIG5vdmFzIG1lbnNhZ2VucyBwb3IgdsOhcmlhcyB0ZW50YXRpdmFzIGNvbnNlY3V0aXZhc1xyXG4gICAgICAgIGlmIChjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMgPj0gZW1wdHlBdHRlbXB0c1RvU3RvcCkge1xyXG4gICAgICAgICAgaWYgKHJlY2VpdmVkTWVzc2FnZXMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKPue+4jyBQYXJhbmRvIHBvbGxpbmc6ICR7ZW1wdHlBdHRlbXB0c1RvU3RvcH0gdGVudGF0aXZhcyBjb25zZWN1dGl2YXMgc2VtIG5vdmFzIG1lbnNhZ2Vucy4gVG90YWw6ICR7cmVjZWl2ZWRNZXNzYWdlcy5zaXplfSBtZW5zYWdlbnMgcmVjZWJpZGFzYCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRlbXB0ID49IDUpIHtcclxuICAgICAgICAgICAgLy8gU2UgbsOjbyByZWNlYmV1IG5lbmh1bWEgbWVuc2FnZW0gYXDDs3MgNSB0ZW50YXRpdmFzLCB0YW1iw6ltIHBhcmFcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKPue+4jyBQYXJhbmRvIHBvbGxpbmc6IE5lbmh1bWEgbWVuc2FnZW0gcmVjZWJpZGEgYXDDs3MgJHthdHRlbXB0ICsgMX0gdGVudGF0aXZhc2ApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gVGVudGF0aXZhICR7YXR0ZW1wdCArIDF9OiBTdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEVycm8gbmEgdGVudGF0aXZhICR7YXR0ZW1wdCArIDF9IGRlIHBvbGxpbmc6YCwgZXJyb3IpO1xyXG4gICAgICAvLyBDb250aW51YSB0ZW50YW5kbyBtZXNtbyBjb20gZXJyb1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFzTWVzc2FnZXMgPSByZWNlaXZlZE1lc3NhZ2VzLnNpemUgPiAwO1xyXG4gIGlmICghaGFzTWVzc2FnZXMpIHtcclxuICAgIGNvbnNvbGUud2Fybihg4o+x77iPIFRpbWVvdXQ6IE7Do28gZm9pIHBvc3PDrXZlbCBvYnRlciBtZW5zYWdlbnMgYXDDs3MgJHttYXhBdHRlbXB0c30gdGVudGF0aXZhc2ApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIFBvbGxpbmcgZmluYWxpemFkby4gVG90YWwgZGUgJHtyZWNlaXZlZE1lc3NhZ2VzLnNpemV9IG1lbnNhZ2VucyByZWNlYmlkYXNgKTtcclxuICB9XHJcbiAgcmV0dXJuIGhhc01lc3NhZ2VzO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFpIG3Dumx0aXBsYXMgbWVuc2FnZW5zIGRvIGZvcm1hdG8gcmV0b3JuYWRvIHBlbG8gTjhOXHJcbiAqIFN1cG9ydGEgYXJyYXlzIGRlIG1lbnNhZ2VucyBvdSBtZW5zYWdlbSDDum5pY2FcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhkYXRhOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgY29uc29sZS5sb2coXCLwn5SNIGV4dHJhY3RNZXNzYWdlcyBjaGFtYWRvIGNvbTpcIiwgdHlwZW9mIGRhdGEsIEFycmF5LmlzQXJyYXkoZGF0YSkgPyBgYXJyYXlbJHtkYXRhLmxlbmd0aH1dYCA6IGRhdGEpO1xyXG4gIFxyXG4gIC8vIFNlIGZvciBzdHJpbmcsIHRlbnRhIHBhcnNlYXIgY29tbyBKU09OXHJcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICByZXR1cm4gZXh0cmFjdE1lc3NhZ2VzKHBhcnNlZCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gU2UgbsOjbyBmb3IgSlNPTiB2w6FsaWRvLCByZXRvcm5hIGNvbW8gYXJyYXkgY29tIHVtYSBtZW5zYWdlbVxyXG4gICAgICByZXR1cm4gZGF0YS50cmltKCkgPyBbZGF0YV0gOiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNlIGZvciB1bSBhcnJheSwgcHJvY2Vzc2EgY2FkYSBpdGVtXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OmIFByb2Nlc3NhbmRvIGFycmF5IGNvbSAke2RhdGEubGVuZ3RofSBpdGVuc2ApO1xyXG4gICAgY29uc3QgbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFByb2Nlc3NhbmRvIGl0ZW0gJHtpbmRleCArIDF9LyR7ZGF0YS5sZW5ndGh9OmAsIGl0ZW0pO1xyXG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSBleHRyYWN0UmVzcG9uc2UoaXRlbSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIEl0ZW0gJHtpbmRleCArIDF9IGV4dHJhw61kbzpgLCBleHRyYWN0ZWQ/LnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgICAgaWYgKGV4dHJhY3RlZCAmJiBleHRyYWN0ZWQudHJpbSgpKSB7XHJcbiAgICAgICAgbWVzc2FnZXMucHVzaChleHRyYWN0ZWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBJdGVtICR7aW5kZXggKyAxfSBuw6NvIHRpbmhhIGNvbnRlw7pkbyB2w6FsaWRvYCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coYOKchSBUb3RhbCBkZSAke21lc3NhZ2VzLmxlbmd0aH0gbWVuc2FnZW5zIGV4dHJhw61kYXMgZG8gYXJyYXlgKTtcclxuICAgIHJldHVybiBtZXNzYWdlcztcclxuICB9XHJcblxyXG4gIC8vIFNlIGZvciBvYmpldG8sIGV4dHJhaSBhIG1lbnNhZ2VtXHJcbiAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IGV4dHJhY3RSZXNwb25zZShkYXRhKTtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OdIE9iamV0byBleHRyYcOtZG86YCwgZXh0cmFjdGVkPy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICByZXR1cm4gZXh0cmFjdGVkICYmIGV4dHJhY3RlZC50cmltKCkgPyBbZXh0cmFjdGVkXSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIuKaoO+4jyBUaXBvIGRlIGRhZG9zIG7Do28gcmVjb25oZWNpZG8sIHJldG9ybmFuZG8gYXJyYXkgdmF6aW9cIik7XHJcbiAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG4vKipcclxuICogRW52aWEgdW1hIG1lbnNhZ2VtIHBhcmEgbyB3ZWJob29rIE44TiBlIHJlY2ViZSBtw7psdGlwbGFzIG1lbnNhZ2VucyBzZXBhcmFkYXNcclxuICogU2UgYSByZXNwb3N0YSBpbmljaWFsIGZvciBcIndvcmtmbG93IGluaWNpYWRvXCIsIGZheiBwb2xsaW5nIGF0w6kgcmVjZWJlciBhcyBtZW5zYWdlbnNcclxuICogQHBhcmFtIG1lc3NhZ2UgLSBBIG1lbnNhZ2VtIGRvIHVzdcOhcmlvXHJcbiAqIEBwYXJhbSBhZ2VudFR5cGUgLSBUaXBvIGRvIGFnZW50ZSBJQSAoc2RyLCBlY29tbWVyY2UsIGFnZW5kYW1lbnRvKVxyXG4gKiBAcGFyYW0gb25OZXdNZXNzYWdlIC0gQ2FsbGJhY2sgY2hhbWFkbyBwYXJhIGNhZGEgbm92YSBtZW5zYWdlbSByZWNlYmlkYSBkYSBJQVxyXG4gKiBAcGFyYW0gb25Qb2xsaW5nIC0gQ2FsbGJhY2sgY2hhbWFkbyBkdXJhbnRlIG8gcG9sbGluZyAocGFyYSBhbmltYcOnw6NvKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRNZXNzYWdlVG9XZWJob29rKFxyXG4gIG1lc3NhZ2U6IHN0cmluZyxcclxuICBhZ2VudFR5cGU6IEFnZW50VHlwZSxcclxuICBzZXNzaW9uSWQ6IHN0cmluZyxcclxuICBvbk5ld01lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgb25Qb2xsaW5nPzogKGlzUG9sbGluZzogYm9vbGVhbikgPT4gdm9pZFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCFzZXNzaW9uSWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2Vzc2lvbklkIMOpIG9icmlnYXTDs3JpbyBwYXJhIGVudmlhciBtZW5zYWdlbnNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGF5bG9hZDogV2ViaG9va01lc3NhZ2UgPSB7XHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UudHJpbSgpLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXHJcbiAgICAgIGFnZW50VHlwZTogYWdlbnRUeXBlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2cgcGFyYSBkZWJ1Z1xyXG4gICAgY29uc29sZS5sb2coXCJFbnZpYW5kbyBtZW5zYWdlbSBwYXJhIHdlYmhvb2s6XCIsIHtcclxuICAgICAgdXJsOiBXRUJIT09LX1VSTCxcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goV0VCSE9PS19VUkwsIHtcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiUmVzcG9zdGEgZG8gd2ViaG9vazpcIiwge1xyXG4gICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcclxuICAgICAgb2s6IHJlc3BvbnNlLm9rLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIG5hIHJlc3Bvc3RhIGRvIHdlYmhvb2s6XCIsIHtcclxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxyXG4gICAgICAgIGJvZHk6IGVycm9yVGV4dCxcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJybyBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlbnRhIHBhcnNlYXIgY29tbyBKU09OLCBtYXMgdGFtYsOpbSBzdXBvcnRhIHRleHRvIHNpbXBsZXNcclxuICAgIGxldCBkYXRhOiBXZWJob29rUmVzcG9uc2UgfCBzdHJpbmc7XHJcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XHJcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgIGRhdGEgPSB0ZXh0O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIHBhcnNlYXIgcmVzcG9zdGE6XCIsIHBhcnNlRXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvIGFvIHByb2Nlc3NhciByZXNwb3N0YSBkbyB3ZWJob29rXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiRGFkb3MgcGFyc2VhZG9zOlwiLCBkYXRhKTtcclxuXHJcbiAgICAvLyBFeHRyYWkgYXMgbWVuc2FnZW5zIGRvIGZvcm1hdG8gcmV0b3JuYWRvIHBlbG8gTjhOXHJcbiAgICBjb25zdCBtZXNzYWdlcyA9IGV4dHJhY3RNZXNzYWdlcyhkYXRhKTtcclxuICAgIGNvbnNvbGUubG9nKFwiTWVuc2FnZW5zIGV4dHJhw61kYXM6XCIsIG1lc3NhZ2VzKTtcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2Egc2UgbyB3b3JrZmxvdyBmb2kgaW5pY2lhZG8gKGluZGljYSBxdWUgbWFpcyBtZW5zYWdlbnMgcG9kZW0gdmlyKVxyXG4gICAgY29uc3QgaXNXb3JrZmxvd1N0YXJ0ZWQgPSBtZXNzYWdlcy5zb21lKG1zZyA9PiBpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKG1zZykpO1xyXG4gICAgY29uc3QgdmFsaWRNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gIWlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UobXNnKSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5OKIFdvcmtmbG93IGluaWNpYWRvPyAke2lzV29ya2Zsb3dTdGFydGVkfSwgTWVuc2FnZW5zIHbDoWxpZGFzIG5hIHJlc3Bvc3RhIGluaWNpYWw6ICR7dmFsaWRNZXNzYWdlcy5sZW5ndGh9YCk7XHJcbiAgICBcclxuICAgIC8vIFByb2Nlc3NhIG1lbnNhZ2VucyBkYSByZXNwb3N0YSBpbmljaWFsIHByaW1laXJvIChzZSBob3V2ZXIpXHJcbiAgICBpZiAodmFsaWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OoIFByb2Nlc3NhbmRvICR7dmFsaWRNZXNzYWdlcy5sZW5ndGh9IG1lbnNhZ2VucyBkYSByZXNwb3N0YSBpbmljaWFsYCk7XHJcbiAgICAgIHZhbGlkTWVzc2FnZXMuZm9yRWFjaCgobXNnLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OkIEVudmlhbmRvIG1lbnNhZ2VtICR7aW5kZXggKyAxfS8ke3ZhbGlkTWVzc2FnZXMubGVuZ3RofSBkYSByZXNwb3N0YSBpbmljaWFsOmAsIG1zZy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgICAgb25OZXdNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBDYWxsYmFjayBvbk5ld01lc3NhZ2UgY2hhbWFkbyBwYXJhIG1lbnNhZ2VtICR7aW5kZXggKyAxfWApO1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBUb2RhcyBhcyAke3ZhbGlkTWVzc2FnZXMubGVuZ3RofSBtZW5zYWdlbnMgZGEgcmVzcG9zdGEgaW5pY2lhbCBmb3JhbSBlbnZpYWRhc2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBOZW5odW1hIG1lbnNhZ2VtIHbDoWxpZGEgZW5jb250cmFkYSBuYSByZXNwb3N0YSBpbmljaWFsYCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNlbXByZSBmYXplbW9zIHBvbGxpbmcgbmEgQVBJIGludGVybmEgZGUgbWVuc2FnZW5zIHBhcmEgdHJhemVyIGFzIHJlc3Bvc3RhcyBxdWUgbyBmbHV4byBlbnZpb3UgdmlhIEhUVFAgUmVxdWVzdDFcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UhCBJbmljaWFuZG8gcG9sbGluZyBuYSBBUEkgaW50ZXJuYSAvYXBpL2NoYXQvbWVzc2FnZXMgcGFyYSBidXNjYXIgcmVzcG9zdGFzIGRvIGZsdXhvXCIpO1xyXG4gICAgaWYgKG9uUG9sbGluZykgb25Qb2xsaW5nKHRydWUpO1xyXG4gICAgYXdhaXQgcG9sbENoYXRNZXNzYWdlcyhzZXNzaW9uSWQsIG9uTmV3TWVzc2FnZSwgdmFsaWRNZXNzYWdlcyk7XHJcbiAgICBpZiAob25Qb2xsaW5nKSBvblBvbGxpbmcoZmFsc2UpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBjb21wbGV0byBhbyBlbnZpYXIgbWVuc2FnZW0gcGFyYSB3ZWJob29rOlwiLCB7XHJcbiAgICAgIGVycm9yLFxyXG4gICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRXJybyBkZXNjb25oZWNpZG9cIixcclxuICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmF6IHBvbGxpbmcgbmEgQVBJIGludGVybmEgKC9hcGkvY2hhdC9tZXNzYWdlcykgcGFyYSBidXNjYXIgbWVuc2FnZW5zIHBlcnNpc3RpZGFzIHBlbG8gZmx1eG9cclxuICovXHJcbi8vIE5vcm1hbGl6YSBtZW5zYWdlbSBwYXJhIGNvbXBhcmHDp8OjbyAocmVtb3ZlIGVzcGHDp29zIGV4dHJhcywgcXVlYnJhcyBkZSBsaW5oYSwgZXRjKVxyXG5mdW5jdGlvbiBub3JtYWxpemVNZXNzYWdlKG1zZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gbXNnLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gcG9sbENoYXRNZXNzYWdlcyhcclxuICBzZXNzaW9uSWQ6IHN0cmluZyxcclxuICBvbk5ld01lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgaW5pdGlhbE1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdLFxyXG4gIG1heEF0dGVtcHRzOiBudW1iZXIgPSA4MCwgICAgICAgICAgLy8gfjE2MHMgbm8gcGlvciBjYXNvICg4MCAqIDJzKVxyXG4gIGludGVydmFsTXM6IG51bWJlciA9IDIwMDAsICAgICAgICAgLy8gMnMgZW50cmUgdGVudGF0aXZhc1xyXG4gIGVtcHR5QXR0ZW1wdHNUb1N0b3A6IG51bWJlciA9IDgsICAgLy8gcGFyYSBhcMOzcyA4IHRlbnRhdGl2YXMgdmF6aWFzIHNlZ3VpZGFzXHJcbiAgbWluQXR0ZW1wdHNCZWZvcmVTdG9wOiBudW1iZXIgPSA2ICAvLyBnYXJhbnRlIGFvIG1lbm9zIDYgdGVudGF0aXZhcyBhbnRlcyBkZSBwYXJhclxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBsZXQgY3Vyc29yID0gLTE7XHJcbiAgbGV0IGNvbnNlY3V0aXZlRW1wdHkgPSAwO1xyXG4gIC8vIFVzYSBub3JtYWxpemHDp8OjbyBwYXJhIGNvbXBhcmHDp8OjbyBkZSBtZW5zYWdlbnNcclxuICBjb25zdCByZWNlaXZlZCA9IG5ldyBTZXQ8c3RyaW5nPihpbml0aWFsTWVzc2FnZXMubWFwKG5vcm1hbGl6ZU1lc3NhZ2UpKTtcclxuXHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XHJcbiAgICAvLyBlc3BlcmEgZW50cmUgdGVudGF0aXZhcywgZXhjZXRvIG5hIHByaW1laXJhXHJcbiAgICBpZiAoYXR0ZW1wdCA+IDApIHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgaW50ZXJ2YWxNcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVybCA9IGAke0NIQVRfQVBJX1VSTH0/c2Vzc2lvbklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlc3Npb25JZCl9JmN1cnNvcj0ke2N1cnNvcn1gO1xyXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2godXJsLCB7IG1ldGhvZDogXCJHRVRcIiB9KTtcclxuICAgICAgaWYgKCFyZXNwLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gUG9sbGluZyBjaGF0IEFQSSBzdGF0dXMgJHtyZXNwLnN0YXR1c30gbmEgdGVudGF0aXZhICR7YXR0ZW1wdCArIDF9YCk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwLmpzb24oKTtcclxuICAgICAgY29uc3QgbWVzc2FnZXM6IHsgdGV4dD86IHN0cmluZyB9W10gPSBkYXRhPy5tZXNzYWdlcyA/PyBbXTtcclxuICAgICAgY29uc3QgbGFzdElkeDogbnVtYmVyID0gdHlwZW9mIGRhdGE/Lmxhc3RJZHggPT09IFwibnVtYmVyXCIgPyBkYXRhLmxhc3RJZHggOiBjdXJzb3I7XHJcblxyXG4gICAgICBsZXQgbmV3Q291bnQgPSAwO1xyXG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKChtKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdHh0ID0gKG0/LnRleHQgPz8gXCJcIikudHJpbSgpO1xyXG4gICAgICAgIGlmICghdHh0IHx8IHR4dC50b0xvd2VyQ2FzZSgpID09PSBcIm51bGxcIiB8fCBpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKHR4dCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU1lc3NhZ2UodHh0KTtcclxuICAgICAgICBpZiAoIXJlY2VpdmVkLmhhcyhub3JtYWxpemVkKSkge1xyXG4gICAgICAgICAgcmVjZWl2ZWQuYWRkKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgICAgbmV3Q291bnQrKztcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTm92YSBtZW5zYWdlbSBkbyBwb2xsaW5nICgke25ld0NvdW50fSk6YCwgdHh0LnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgICAgICAgIG9uTmV3TWVzc2FnZSh0eHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE1lbnNhZ2VtIGR1cGxpY2FkYSBpZ25vcmFkYSBubyBwb2xsaW5nOmAsIHR4dC5zdWJzdHJpbmcoMCwgNTApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKG5ld0NvdW50ID4gMCkge1xyXG4gICAgICAgIGN1cnNvciA9IGxhc3RJZHg7XHJcbiAgICAgICAgY29uc2VjdXRpdmVFbXB0eSA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc2VjdXRpdmVFbXB0eSsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29uc2VjdXRpdmVFbXB0eSA+PSBlbXB0eUF0dGVtcHRzVG9TdG9wICYmIGF0dGVtcHQgKyAxID49IG1pbkF0dGVtcHRzQmVmb3JlU3RvcCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRXJybyBhbyBmYXplciBwb2xsaW5nIGRhIGNoYXQgQVBJIG5hIHRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfTpgLCBlcnIpO1xyXG4gICAgICAvLyBjb250aW51YSB0ZW50YW5kb1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhaSBhIHJlc3Bvc3RhIGRvIGZvcm1hdG8gcmV0b3JuYWRvIHBlbG8gTjhOXHJcbiAqIFN1cG9ydGEgZGlmZXJlbnRlcyBmb3JtYXRvcyBkZSByZXNwb3N0YSwgaW5jbHVpbmRvIGFycmF5cyBKU09OXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0UmVzcG9uc2UoZGF0YTogV2ViaG9va1Jlc3BvbnNlIHwgc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBTZSBmb3Igc3RyaW5nLCB0ZW50YSBwYXJzZWFyIGNvbW8gSlNPTiBwcmltZWlyb1xyXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgLy8gVGVudGEgcGFyc2VhciBjb21vIEpTT05cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgIC8vIFNlIHBhcnNlb3UgY29tIHN1Y2Vzc28sIHByb2Nlc3NhIG8gb2JqZXRvL2FycmF5XHJcbiAgICAgIHJldHVybiBleHRyYWN0UmVzcG9uc2UocGFyc2VkKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICAvLyBTZSBuw6NvIGZvciBKU09OIHbDoWxpZG8sIHJldG9ybmEgYSBzdHJpbmcgY29tbyBlc3TDoVxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNlIGZvciB1bSBhcnJheSwgcGVnYSBvIHByaW1laXJvIGVsZW1lbnRvXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBmaXJzdEl0ZW0gPSBkYXRhWzBdO1xyXG4gICAgLy8gU2UgbyBwcmltZWlybyBpdGVtIHRpdmVyIGNhbXBvIFwib3V0cHV0XCIsIHJldG9ybmEgZWxlXHJcbiAgICBpZiAoZmlyc3RJdGVtICYmIHR5cGVvZiBmaXJzdEl0ZW0gPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiBmaXJzdEl0ZW0pIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhmaXJzdEl0ZW0ub3V0cHV0IHx8IFwiXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gU2UgbsOjbywgdGVudGEgZXh0cmFpciBkbyBwcmltZWlybyBpdGVtXHJcbiAgICByZXR1cm4gZXh0cmFjdFJlc3BvbnNlKGZpcnN0SXRlbSk7XHJcbiAgfVxyXG5cclxuICAvLyBTZSBmb3Igb2JqZXRvLCB0ZW50YSBkaWZlcmVudGVzIGNhbXBvcyBjb211bnMgZGUgcmVzcG9zdGFcclxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgLy8gUHJpb3JpemEgbyBjYW1wbyBcInRleHRcIiAoZm9ybWF0byBjb211bSBkbyBOOE4pXHJcbiAgICBpZiAoXCJ0ZXh0XCIgaW4gZGF0YSAmJiBkYXRhLnRleHQpIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk50gQ2FtcG8gXCJ0ZXh0XCIgZW5jb250cmFkbzpgLCBTdHJpbmcoZGF0YS50ZXh0KS5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0YS50ZXh0KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUHJpb3JpemEgbyBjYW1wbyBcIm91dHB1dFwiIHNlIGV4aXN0aXJcclxuICAgIGlmIChcIm91dHB1dFwiIGluIGRhdGEgJiYgZGF0YS5vdXRwdXQpIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhkYXRhLm91dHB1dCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRlbnRhIG91dHJvcyBjYW1wb3MgY29tdW5zXHJcbiAgICBpZiAoZGF0YS5yZXNwb25zZSkgcmV0dXJuIFN0cmluZyhkYXRhLnJlc3BvbnNlKTtcclxuICAgIGlmIChkYXRhLm1lc3NhZ2UpIHJldHVybiBTdHJpbmcoZGF0YS5tZXNzYWdlKTtcclxuICAgIFxyXG4gICAgLy8gVGVudGEgY2FtcG9zIGFuaW5oYWRvc1xyXG4gICAgaWYgKGRhdGEub3V0cHV0ICYmIHR5cGVvZiBkYXRhLm91dHB1dCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gZGF0YS5vdXRwdXQpIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQubWVzc2FnZSk7XHJcbiAgICAgIGlmIChcInJlc3BvbnNlXCIgaW4gZGF0YS5vdXRwdXQpIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQucmVzcG9uc2UpO1xyXG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gZGF0YS5vdXRwdXQpIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQudGV4dCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTZSBuw6NvIGVuY29udHJhciBuZW5odW0gY2FtcG8gY29uaGVjaWRvLCByZXRvcm5hIG8gSlNPTiBzdHJpbmdpZmljYWRvXHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiV0VCSE9PS19VUkwiLCJDSEFUX0FQSV9VUkwiLCJjcmVhdGVTZXNzaW9uSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiV09SS0ZMT1dfU1RBUlRFRF9NRVNTQUdFUyIsImlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UiLCJyZXNwb25zZSIsImxvd2VyUmVzcG9uc2UiLCJ0b0xvd2VyQ2FzZSIsInNvbWUiLCJtc2ciLCJpbmNsdWRlcyIsInBvbGxGb3JNZXNzYWdlcyIsInNlc3Npb25JZCIsIm9uTmV3TWVzc2FnZSIsImluaXRpYWxNZXNzYWdlcyIsIm1heEF0dGVtcHRzIiwiaW50ZXJ2YWxNcyIsImVtcHR5QXR0ZW1wdHNUb1N0b3AiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwicmVjZWl2ZWRNZXNzYWdlcyIsIlNldCIsIm1hcCIsIm5vcm1hbGl6ZU1lc3NhZ2UiLCJjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMiLCJhdHRlbXB0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjaGVja1N0YXR1cyIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwib2siLCJjb250ZW50VHlwZSIsImdldCIsImRhdGEiLCJqc29uIiwidGV4dCIsIm1lc3NhZ2VzIiwiZXh0cmFjdE1lc3NhZ2VzIiwibmV3TWVzc2FnZXNDb3VudCIsImZvckVhY2giLCJ0cmltbWVkTXNnIiwidHJpbSIsImhhcyIsImFkZCIsInNpemUiLCJ3YXJuIiwic3RhdHVzIiwiZXJyb3IiLCJoYXNNZXNzYWdlcyIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlZCIsInBhcnNlIiwiaXRlbSIsImluZGV4IiwiZXh0cmFjdGVkIiwiZXh0cmFjdFJlc3BvbnNlIiwicHVzaCIsInNlbmRNZXNzYWdlVG9XZWJob29rIiwibWVzc2FnZSIsImFnZW50VHlwZSIsIm9uUG9sbGluZyIsIkVycm9yIiwicGF5bG9hZCIsInVybCIsInN0YXR1c1RleHQiLCJlcnJvclRleHQiLCJjYXRjaCIsInBhcnNlRXJyb3IiLCJpc1dvcmtmbG93U3RhcnRlZCIsInZhbGlkTWVzc2FnZXMiLCJmaWx0ZXIiLCJwb2xsQ2hhdE1lc3NhZ2VzIiwic3RhY2siLCJ1bmRlZmluZWQiLCJyZXBsYWNlIiwibWluQXR0ZW1wdHNCZWZvcmVTdG9wIiwiY3Vyc29yIiwiY29uc2VjdXRpdmVFbXB0eSIsInJlY2VpdmVkIiwiciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3AiLCJsYXN0SWR4IiwibmV3Q291bnQiLCJtIiwidHh0Iiwibm9ybWFsaXplZCIsImVyciIsImZpcnN0SXRlbSIsIlN0cmluZyIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/webhookService.ts\n"));

/***/ })

});