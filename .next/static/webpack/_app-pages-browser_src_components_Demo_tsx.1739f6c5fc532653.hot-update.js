"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Demo_tsx",{

/***/ "(app-pages-browser)/./src/services/webhookService.ts":
/*!****************************************!*\
  !*** ./src/services/webhookService.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSessionId: function() { return /* binding */ createSessionId; },\n/* harmony export */   isWorkflowStartedResponse: function() { return /* binding */ isWorkflowStartedResponse; },\n/* harmony export */   sendMessageToWebhook: function() { return /* binding */ sendMessageToWebhook; }\n/* harmony export */ });\n/**\r\n * Serviço para comunicação com o webhook N8N\r\n */ const WEBHOOK_URL = \"https://webhook.agentemwd.com/webhook/9de471bd-4296-4cc8-bc40-f2ea1d19f6dd\";\nconst CHAT_API_URL = \"/api/chat/messages\";\n/**\r\n * Gera um ID único para a sessão ou recupera o existente do sessionStorage\r\n * O ID é único por sessão do navegador (recarrega quando a página é recarregada)\r\n * @returns ID único da sessão\r\n */ function createSessionId() {\n    return \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 15));\n}\n// Mensagens que indicam que o workflow foi iniciado mas ainda não há resposta\nconst WORKFLOW_STARTED_MESSAGES = [\n    \"workflow foi iniciado\",\n    \"workflow iniciado\",\n    \"workflow started\",\n    \"processando\",\n    \"processando sua mensagem\",\n    \"aguarde\",\n    \"workflow was started\"\n];\n/**\r\n * Verifica se a resposta indica que o workflow foi iniciado mas ainda não há resposta final\r\n */ function isWorkflowStartedResponse(response) {\n    const lowerResponse = response.toLowerCase();\n    return WORKFLOW_STARTED_MESSAGES.some((msg)=>lowerResponse.includes(msg));\n}\n/**\r\n * Faz polling para verificar se há mensagens disponíveis\r\n * IMPORTANTE: Apenas verifica status, NÃO inicia novas execuções\r\n * @param sessionId - ID da sessão\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida\r\n * @param maxAttempts - Número máximo de tentativas (padrão: 30 = 60 segundos)\r\n * @param intervalMs - Intervalo entre tentativas em ms (padrão: 2000 = 2 segundos)\r\n * @param emptyAttemptsToStop - Número de tentativas vazias consecutivas para parar (padrão: 2)\r\n * @returns true se recebeu mensagens, false se timeout\r\n */ async function pollForMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 30, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;\n    console.log(\"\\uD83D\\uDD04 Iniciando polling APENAS para verificar status. SessionId: \".concat(sessionId, \", m\\xe1ximo \").concat(maxAttempts, \" tentativas\"));\n    console.log(\"\\uD83D\\uDCCB Mensagens j\\xe1 recebidas na primeira resposta: \".concat(initialMessages.length));\n    const receivedMessages = new Set(initialMessages); // Inclui mensagens já recebidas para evitar duplicatas\n    let consecutiveEmptyAttempts = 0; // Contador de tentativas consecutivas sem novas mensagens\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // Aguarda antes de fazer a próxima tentativa (exceto na primeira)\n        if (attempt > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, intervalMs));\n        }\n        try {\n            // IMPORTANTE: Apenas verifica status, NÃO envia mensagem nem agentType\n            // Isso evita iniciar novas execuções do workflow\n            const response = await fetch(WEBHOOK_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    sessionId: sessionId,\n                    checkStatus: true,\n                    timestamp: new Date().toISOString()\n                })\n            });\n            if (response.ok) {\n                const contentType = response.headers.get(\"content-type\");\n                let data;\n                if (contentType && contentType.includes(\"application/json\")) {\n                    data = await response.json();\n                } else {\n                    const text = await response.text();\n                    data = text;\n                }\n                // Processa múltiplas mensagens se vierem em array\n                const messages = extractMessages(data);\n                console.log(\"\\uD83D\\uDCE6 Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": \").concat(messages.length, \" mensagens extra\\xeddas\"));\n                let newMessagesCount = 0;\n                // Chama o callback para cada nova mensagem\n                messages.forEach((msg)=>{\n                    const trimmedMsg = msg.trim();\n                    if (trimmedMsg.length > 0 && !isWorkflowStartedResponse(trimmedMsg) && trimmedMsg.toLowerCase() !== \"null\" && trimmedMsg.toLowerCase() !== \"undefined\" && !receivedMessages.has(trimmedMsg)) {\n                        receivedMessages.add(trimmedMsg);\n                        newMessagesCount++;\n                        console.log(\"✅ Nova mensagem \".concat(newMessagesCount, \" recebida na tentativa \").concat(attempt + 1, \":\"), trimmedMsg.substring(0, 100));\n                        onNewMessage(trimmedMsg);\n                    }\n                });\n                // Se recebeu novas mensagens, reseta o contador de tentativas vazias\n                if (newMessagesCount > 0) {\n                    consecutiveEmptyAttempts = 0;\n                    console.log(\"\\uD83D\\uDCCA Total de mensagens recebidas at\\xe9 agora: \".concat(receivedMessages.size));\n                } else {\n                    consecutiveEmptyAttempts++;\n                    console.log(\"⏳ Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": Sem novas mensagens (\").concat(consecutiveEmptyAttempts, \"/\").concat(emptyAttemptsToStop, \" tentativas vazias consecutivas)\"));\n                }\n                // Para o polling se não houver novas mensagens por várias tentativas consecutivas\n                if (consecutiveEmptyAttempts >= emptyAttemptsToStop) {\n                    if (receivedMessages.size > 0) {\n                        console.log(\"⏹️ Parando polling: \".concat(emptyAttemptsToStop, \" tentativas consecutivas sem novas mensagens. Total: \").concat(receivedMessages.size, \" mensagens recebidas\"));\n                        break;\n                    } else if (attempt >= 5) {\n                        // Se não recebeu nenhuma mensagem após 5 tentativas, também para\n                        console.log(\"⏹️ Parando polling: Nenhuma mensagem recebida ap\\xf3s \".concat(attempt + 1, \" tentativas\"));\n                        break;\n                    }\n                }\n            } else {\n                console.warn(\"⚠️ Tentativa \".concat(attempt + 1, \": Status \").concat(response.status));\n            }\n        } catch (error) {\n            console.warn(\"⚠️ Erro na tentativa \".concat(attempt + 1, \" de polling:\"), error);\n        // Continua tentando mesmo com erro\n        }\n    }\n    const hasMessages = receivedMessages.size > 0;\n    if (!hasMessages) {\n        console.warn(\"⏱️ Timeout: N\\xe3o foi poss\\xedvel obter mensagens ap\\xf3s \".concat(maxAttempts, \" tentativas\"));\n    } else {\n        console.log(\"✅ Polling finalizado. Total de \".concat(receivedMessages.size, \" mensagens recebidas\"));\n    }\n    return hasMessages;\n}\n/**\r\n * Extrai múltiplas mensagens do formato retornado pelo N8N\r\n * Suporta arrays de mensagens ou mensagem única\r\n */ function extractMessages(data) {\n    console.log(\"\\uD83D\\uDD0D extractMessages chamado com:\", typeof data, Array.isArray(data) ? \"array[\".concat(data.length, \"]\") : data);\n    // Se for string, tenta parsear como JSON\n    if (typeof data === \"string\") {\n        try {\n            const parsed = JSON.parse(data);\n            return extractMessages(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna como array com uma mensagem\n            return data.trim() ? [\n                data\n            ] : [];\n        }\n    }\n    // Se for um array, processa cada item\n    if (Array.isArray(data)) {\n        console.log(\"\\uD83D\\uDCE6 Processando array com \".concat(data.length, \" itens\"));\n        const messages = [];\n        data.forEach((item, index)=>{\n            console.log(\"\\uD83D\\uDD0D Processando item \".concat(index + 1, \"/\").concat(data.length, \":\"), item);\n            const extracted = extractResponse(item);\n            console.log(\"\\uD83D\\uDCDD Item \".concat(index + 1, \" extra\\xeddo:\"), extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n            if (extracted && extracted.trim()) {\n                messages.push(extracted);\n            } else {\n                console.log(\"⚠️ Item \".concat(index + 1, \" n\\xe3o tinha conte\\xfado v\\xe1lido\"));\n            }\n        });\n        console.log(\"✅ Total de \".concat(messages.length, \" mensagens extra\\xeddas do array\"));\n        return messages;\n    }\n    // Se for objeto, extrai a mensagem\n    if (data && typeof data === \"object\") {\n        const extracted = extractResponse(data);\n        console.log(\"\\uD83D\\uDCDD Objeto extra\\xeddo:\", extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n        return extracted && extracted.trim() ? [\n            extracted\n        ] : [];\n    }\n    console.log(\"⚠️ Tipo de dados n\\xe3o reconhecido, retornando array vazio\");\n    return [];\n}\n/**\r\n * Envia uma mensagem para o webhook N8N e recebe múltiplas mensagens separadas\r\n * Se a resposta inicial for \"workflow iniciado\", faz polling até receber as mensagens\r\n * @param message - A mensagem do usuário\r\n * @param agentType - Tipo do agente IA (sdr, ecommerce, agendamento)\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida da IA\r\n * @param onPolling - Callback chamado durante o polling (para animação)\r\n */ async function sendMessageToWebhook(message, agentType, sessionId, onNewMessage, onPolling) {\n    try {\n        if (!sessionId) {\n            throw new Error(\"sessionId \\xe9 obrigat\\xf3rio para enviar mensagens\");\n        }\n        const payload = {\n            message: message.trim(),\n            timestamp: new Date().toISOString(),\n            sessionId: sessionId,\n            agentType: agentType\n        };\n        // Log para debug\n        console.log(\"Enviando mensagem para webhook:\", {\n            url: WEBHOOK_URL,\n            method: \"POST\",\n            payload: payload\n        });\n        const response = await fetch(WEBHOOK_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload)\n        });\n        console.log(\"Resposta do webhook:\", {\n            status: response.status,\n            statusText: response.statusText,\n            ok: response.ok\n        });\n        if (!response.ok) {\n            const errorText = await response.text().catch(()=>response.statusText);\n            console.error(\"Erro na resposta do webhook:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Erro HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Tenta parsear como JSON, mas também suporta texto simples\n        let data;\n        const contentType = response.headers.get(\"content-type\");\n        try {\n            if (contentType && contentType.includes(\"application/json\")) {\n                data = await response.json();\n            } else {\n                const text = await response.text();\n                data = text;\n            }\n        } catch (parseError) {\n            console.error(\"Erro ao parsear resposta:\", parseError);\n            throw new Error(\"Erro ao processar resposta do webhook\");\n        }\n        console.log(\"Dados parseados:\", data);\n        // Extrai as mensagens do formato retornado pelo N8N\n        const messages = extractMessages(data);\n        console.log(\"Mensagens extra\\xeddas:\", messages);\n        // Verifica se o workflow foi iniciado (indica que mais mensagens podem vir)\n        const isWorkflowStarted = messages.some((msg)=>isWorkflowStartedResponse(msg));\n        const validMessages = messages.filter((msg)=>!isWorkflowStartedResponse(msg));\n        console.log(\"\\uD83D\\uDCCA Workflow iniciado? \".concat(isWorkflowStarted, \", Mensagens v\\xe1lidas na resposta inicial: \").concat(validMessages.length));\n        // Processa mensagens da resposta inicial primeiro (se houver)\n        if (validMessages.length > 0) {\n            console.log(\"\\uD83D\\uDCE8 Processando \".concat(validMessages.length, \" mensagens da resposta inicial\"));\n            validMessages.forEach((msg, index)=>{\n                console.log(\"\\uD83D\\uDCE4 Enviando mensagem \".concat(index + 1, \"/\").concat(validMessages.length, \" da resposta inicial:\"), msg.substring(0, 100));\n                onNewMessage(msg);\n                console.log(\"✅ Callback onNewMessage chamado para mensagem \".concat(index + 1));\n            });\n            console.log(\"✅ Todas as \".concat(validMessages.length, \" mensagens da resposta inicial foram enviadas\"));\n        } else {\n            console.log(\"⚠️ Nenhuma mensagem v\\xe1lida encontrada na resposta inicial\");\n        }\n        // Sempre fazemos polling na API interna de mensagens para trazer as respostas que o fluxo enviou via HTTP Request1\n        console.log(\"\\uD83D\\uDD04 Iniciando polling na API interna /api/chat/messages para buscar respostas do fluxo\");\n        if (onPolling) onPolling(true);\n        await pollChatMessages(sessionId, onNewMessage, validMessages);\n        if (onPolling) onPolling(false);\n    } catch (error) {\n        console.error(\"Erro completo ao enviar mensagem para webhook:\", {\n            error,\n            message: error instanceof Error ? error.message : \"Erro desconhecido\",\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        throw error;\n    }\n}\n/**\r\n * Faz polling na API interna (/api/chat/messages) para buscar mensagens persistidas pelo fluxo\r\n */ // Normaliza mensagem para comparação (remove espaços extras, quebras de linha, etc)\nfunction normalizeMessage(msg) {\n    return msg.trim().replace(/\\s+/g, \" \").toLowerCase();\n}\nasync function pollChatMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 80, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 8, minAttemptsBeforeStop = arguments.length > 6 && arguments[6] !== void 0 // garante ao menos 6 tentativas antes de parar\n     ? arguments[6] : 6;\n    let cursor = -1;\n    let consecutiveEmpty = 0;\n    // Usa normalização para comparação de mensagens\n    const received = new Set(initialMessages.map(normalizeMessage));\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // espera entre tentativas, exceto na primeira\n        if (attempt > 0) {\n            await new Promise((r)=>setTimeout(r, intervalMs));\n        }\n        try {\n            const url = \"\".concat(CHAT_API_URL, \"?sessionId=\").concat(encodeURIComponent(sessionId), \"&cursor=\").concat(cursor);\n            const resp = await fetch(url, {\n                method: \"GET\"\n            });\n            if (!resp.ok) {\n                console.warn(\"⚠️ Polling chat API status \".concat(resp.status, \" na tentativa \").concat(attempt + 1));\n                continue;\n            }\n            const data = await resp.json();\n            var _data_messages;\n            const messages = (_data_messages = data === null || data === void 0 ? void 0 : data.messages) !== null && _data_messages !== void 0 ? _data_messages : [];\n            const lastIdx = typeof (data === null || data === void 0 ? void 0 : data.lastIdx) === \"number\" ? data.lastIdx : cursor;\n            let newCount = 0;\n            messages.forEach((m)=>{\n                var _m_text;\n                const txt = ((_m_text = m === null || m === void 0 ? void 0 : m.text) !== null && _m_text !== void 0 ? _m_text : \"\").trim();\n                if (txt && !received.has(txt) && !isWorkflowStartedResponse(txt) && txt.toLowerCase() !== \"null\") {\n                    received.add(txt);\n                    newCount++;\n                    onNewMessage(txt);\n                }\n            });\n            if (newCount > 0) {\n                cursor = lastIdx;\n                consecutiveEmpty = 0;\n            } else {\n                consecutiveEmpty++;\n            }\n            if (consecutiveEmpty >= emptyAttemptsToStop && attempt + 1 >= minAttemptsBeforeStop) {\n                break;\n            }\n        } catch (err) {\n            console.warn(\"⚠️ Erro ao fazer polling da chat API na tentativa \".concat(attempt + 1, \":\"), err);\n        // continua tentando\n        }\n    }\n}\n/**\r\n * Extrai a resposta do formato retornado pelo N8N\r\n * Suporta diferentes formatos de resposta, incluindo arrays JSON\r\n */ function extractResponse(data) {\n    // Se for string, tenta parsear como JSON primeiro\n    if (typeof data === \"string\") {\n        // Tenta parsear como JSON\n        try {\n            const parsed = JSON.parse(data);\n            // Se parseou com sucesso, processa o objeto/array\n            return extractResponse(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna a string como está\n            return data;\n        }\n    }\n    // Se for um array, pega o primeiro elemento\n    if (Array.isArray(data) && data.length > 0) {\n        const firstItem = data[0];\n        // Se o primeiro item tiver campo \"output\", retorna ele\n        if (firstItem && typeof firstItem === \"object\" && \"output\" in firstItem) {\n            return String(firstItem.output || \"\");\n        }\n        // Se não, tenta extrair do primeiro item\n        return extractResponse(firstItem);\n    }\n    // Se for objeto, tenta diferentes campos comuns de resposta\n    if (data && typeof data === \"object\") {\n        // Prioriza o campo \"text\" (formato comum do N8N)\n        if (\"text\" in data && data.text) {\n            console.log('\\uD83D\\uDCDD Campo \"text\" encontrado:', String(data.text).substring(0, 100));\n            return String(data.text);\n        }\n        // Prioriza o campo \"output\" se existir\n        if (\"output\" in data && data.output) {\n            return String(data.output);\n        }\n        // Tenta outros campos comuns\n        if (data.response) return String(data.response);\n        if (data.message) return String(data.message);\n        // Tenta campos aninhados\n        if (data.output && typeof data.output === \"object\") {\n            if (\"message\" in data.output) return String(data.output.message);\n            if (\"response\" in data.output) return String(data.output.response);\n            if (\"text\" in data.output) return String(data.output.text);\n        }\n    }\n    // Se não encontrar nenhum campo conhecido, retorna o JSON stringificado\n    return JSON.stringify(data);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWJob29rU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Q0FFQyxHQUVELE1BQU1BLGNBQWM7QUFDcEIsTUFBTUMsZUFBZTtBQVdyQjs7OztDQUlDLEdBQ00sU0FBU0M7SUFDZCxPQUFPLFdBQXlCQyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBK0MsT0FBNUNGLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHO0FBQzFFO0FBYUEsOEVBQThFO0FBQzlFLE1BQU1DLDRCQUE0QjtJQUNoQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7O0NBRUMsR0FDTSxTQUFTQywwQkFBMEJDLFFBQWdCO0lBQ3hELE1BQU1DLGdCQUFnQkQsU0FBU0UsV0FBVztJQUMxQyxPQUFPSiwwQkFBMEJLLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0gsY0FBY0ksUUFBUSxDQUFDRDtBQUN0RTtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELGVBQWVFLGdCQUNiQyxTQUFpQixFQUNqQkMsWUFBdUM7UUFDdkNDLGtCQUFBQSxpRUFBNEIsRUFBRSxFQUM5QkMsY0FBQUEsaUVBQXNCLElBQ3RCQyxhQUFBQSxpRUFBcUIsTUFDckJDLHNCQUFBQSxpRUFBOEI7SUFFOUJDLFFBQVFDLEdBQUcsQ0FBQywyRUFBc0ZKLE9BQXJCSCxXQUFVLGdCQUF1QixPQUFaRyxhQUFZO0lBQzlHRyxRQUFRQyxHQUFHLENBQUMsZ0VBQTBFLE9BQXZCTCxnQkFBZ0JNLE1BQU07SUFFckYsTUFBTUMsbUJBQW1CLElBQUlDLElBQVlSLGtCQUFrQix1REFBdUQ7SUFDbEgsSUFBSVMsMkJBQTJCLEdBQUcsMERBQTBEO0lBRTVGLElBQUssSUFBSUMsVUFBVSxHQUFHQSxVQUFVVCxhQUFhUyxVQUFXO1FBQ3RELGtFQUFrRTtRQUNsRSxJQUFJQSxVQUFVLEdBQUc7WUFDZixNQUFNLElBQUlDLFFB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dHM/NWNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU2VydmnDp28gcGFyYSBjb211bmljYcOnw6NvIGNvbSBvIHdlYmhvb2sgTjhOXHJcbiAqL1xyXG5cclxuY29uc3QgV0VCSE9PS19VUkwgPSBcImh0dHBzOi8vd2ViaG9vay5hZ2VudGVtd2QuY29tL3dlYmhvb2svOWRlNDcxYmQtNDI5Ni00Y2M4LWJjNDAtZjJlYTFkMTlmNmRkXCI7XHJcbmNvbnN0IENIQVRfQVBJX1VSTCA9IFwiL2FwaS9jaGF0L21lc3NhZ2VzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBBZ2VudFR5cGUgPSBcInNkclwiIHwgXCJlY29tbWVyY2VcIiB8IFwiYWdlbmRhbWVudG9cIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va01lc3NhZ2Uge1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICBzZXNzaW9uSWQ6IHN0cmluZztcclxuICBhZ2VudFR5cGU6IEFnZW50VHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlcmEgdW0gSUQgw7puaWNvIHBhcmEgYSBzZXNzw6NvIG91IHJlY3VwZXJhIG8gZXhpc3RlbnRlIGRvIHNlc3Npb25TdG9yYWdlXHJcbiAqIE8gSUQgw6kgw7puaWNvIHBvciBzZXNzw6NvIGRvIG5hdmVnYWRvciAocmVjYXJyZWdhIHF1YW5kbyBhIHDDoWdpbmEgw6kgcmVjYXJyZWdhZGEpXHJcbiAqIEByZXR1cm5zIElEIMO6bmljbyBkYSBzZXNzw6NvXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBzZXNzaW9uXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTUpfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va1Jlc3BvbnNlIHtcclxuICByZXNwb25zZT86IHN0cmluZztcclxuICBtZXNzYWdlPzogc3RyaW5nO1xyXG4gIHRleHQ/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIG91dHB1dD86IHtcclxuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgICByZXNwb25zZT86IHN0cmluZztcclxuICB9O1xyXG59XHJcblxyXG4vLyBNZW5zYWdlbnMgcXVlIGluZGljYW0gcXVlIG8gd29ya2Zsb3cgZm9pIGluaWNpYWRvIG1hcyBhaW5kYSBuw6NvIGjDoSByZXNwb3N0YVxyXG5jb25zdCBXT1JLRkxPV19TVEFSVEVEX01FU1NBR0VTID0gW1xyXG4gIFwid29ya2Zsb3cgZm9pIGluaWNpYWRvXCIsXHJcbiAgXCJ3b3JrZmxvdyBpbmljaWFkb1wiLFxyXG4gIFwid29ya2Zsb3cgc3RhcnRlZFwiLFxyXG4gIFwicHJvY2Vzc2FuZG9cIixcclxuICBcInByb2Nlc3NhbmRvIHN1YSBtZW5zYWdlbVwiLFxyXG4gIFwiYWd1YXJkZVwiLFxyXG4gIFwid29ya2Zsb3cgd2FzIHN0YXJ0ZWRcIixcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBWZXJpZmljYSBzZSBhIHJlc3Bvc3RhIGluZGljYSBxdWUgbyB3b3JrZmxvdyBmb2kgaW5pY2lhZG8gbWFzIGFpbmRhIG7Do28gaMOhIHJlc3Bvc3RhIGZpbmFsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZShyZXNwb25zZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgbG93ZXJSZXNwb25zZSA9IHJlc3BvbnNlLnRvTG93ZXJDYXNlKCk7XHJcbiAgcmV0dXJuIFdPUktGTE9XX1NUQVJURURfTUVTU0FHRVMuc29tZShtc2cgPT4gbG93ZXJSZXNwb25zZS5pbmNsdWRlcyhtc2cpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZheiBwb2xsaW5nIHBhcmEgdmVyaWZpY2FyIHNlIGjDoSBtZW5zYWdlbnMgZGlzcG9uw612ZWlzXHJcbiAqIElNUE9SVEFOVEU6IEFwZW5hcyB2ZXJpZmljYSBzdGF0dXMsIE7Dg08gaW5pY2lhIG5vdmFzIGV4ZWN1w6fDtWVzXHJcbiAqIEBwYXJhbSBzZXNzaW9uSWQgLSBJRCBkYSBzZXNzw6NvXHJcbiAqIEBwYXJhbSBvbk5ld01lc3NhZ2UgLSBDYWxsYmFjayBjaGFtYWRvIHBhcmEgY2FkYSBub3ZhIG1lbnNhZ2VtIHJlY2ViaWRhXHJcbiAqIEBwYXJhbSBtYXhBdHRlbXB0cyAtIE7Dum1lcm8gbcOheGltbyBkZSB0ZW50YXRpdmFzIChwYWRyw6NvOiAzMCA9IDYwIHNlZ3VuZG9zKVxyXG4gKiBAcGFyYW0gaW50ZXJ2YWxNcyAtIEludGVydmFsbyBlbnRyZSB0ZW50YXRpdmFzIGVtIG1zIChwYWRyw6NvOiAyMDAwID0gMiBzZWd1bmRvcylcclxuICogQHBhcmFtIGVtcHR5QXR0ZW1wdHNUb1N0b3AgLSBOw7ptZXJvIGRlIHRlbnRhdGl2YXMgdmF6aWFzIGNvbnNlY3V0aXZhcyBwYXJhIHBhcmFyIChwYWRyw6NvOiAyKVxyXG4gKiBAcmV0dXJucyB0cnVlIHNlIHJlY2ViZXUgbWVuc2FnZW5zLCBmYWxzZSBzZSB0aW1lb3V0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBwb2xsRm9yTWVzc2FnZXMoXHJcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXHJcbiAgb25OZXdNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxyXG4gIGluaXRpYWxNZXNzYWdlczogc3RyaW5nW10gPSBbXSwgLy8gTWVuc2FnZW5zIGrDoSByZWNlYmlkYXMgbmEgcHJpbWVpcmEgcmVzcG9zdGFcclxuICBtYXhBdHRlbXB0czogbnVtYmVyID0gMzAsXHJcbiAgaW50ZXJ2YWxNczogbnVtYmVyID0gMjAwMCxcclxuICBlbXB0eUF0dGVtcHRzVG9TdG9wOiBudW1iZXIgPSAyXHJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGNvbnNvbGUubG9nKGDwn5SEIEluaWNpYW5kbyBwb2xsaW5nIEFQRU5BUyBwYXJhIHZlcmlmaWNhciBzdGF0dXMuIFNlc3Npb25JZDogJHtzZXNzaW9uSWR9LCBtw6F4aW1vICR7bWF4QXR0ZW1wdHN9IHRlbnRhdGl2YXNgKTtcclxuICBjb25zb2xlLmxvZyhg8J+TiyBNZW5zYWdlbnMgasOhIHJlY2ViaWRhcyBuYSBwcmltZWlyYSByZXNwb3N0YTogJHtpbml0aWFsTWVzc2FnZXMubGVuZ3RofWApO1xyXG4gIFxyXG4gIGNvbnN0IHJlY2VpdmVkTWVzc2FnZXMgPSBuZXcgU2V0PHN0cmluZz4oaW5pdGlhbE1lc3NhZ2VzKTsgLy8gSW5jbHVpIG1lbnNhZ2VucyBqw6EgcmVjZWJpZGFzIHBhcmEgZXZpdGFyIGR1cGxpY2F0YXNcclxuICBsZXQgY29uc2VjdXRpdmVFbXB0eUF0dGVtcHRzID0gMDsgLy8gQ29udGFkb3IgZGUgdGVudGF0aXZhcyBjb25zZWN1dGl2YXMgc2VtIG5vdmFzIG1lbnNhZ2Vuc1xyXG4gIFxyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xyXG4gICAgLy8gQWd1YXJkYSBhbnRlcyBkZSBmYXplciBhIHByw7N4aW1hIHRlbnRhdGl2YSAoZXhjZXRvIG5hIHByaW1laXJhKVxyXG4gICAgaWYgKGF0dGVtcHQgPiAwKSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbnRlcnZhbE1zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gSU1QT1JUQU5URTogQXBlbmFzIHZlcmlmaWNhIHN0YXR1cywgTsODTyBlbnZpYSBtZW5zYWdlbSBuZW0gYWdlbnRUeXBlXHJcbiAgICAgIC8vIElzc28gZXZpdGEgaW5pY2lhciBub3ZhcyBleGVjdcOnw7VlcyBkbyB3b3JrZmxvd1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFdFQkhPT0tfVVJMLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLFxyXG4gICAgICAgICAgY2hlY2tTdGF0dXM6IHRydWUsIC8vIEluZGljYSBxdWUgw6kgQVBFTkFTIHVtYSB2ZXJpZmljYcOnw6NvIGRlIHN0YXR1c1xyXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcclxuICAgICAgICBsZXQgZGF0YTogV2ViaG9va1Jlc3BvbnNlIHwgc3RyaW5nIHwgYW55O1xyXG5cclxuICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XHJcbiAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgICAgZGF0YSA9IHRleHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcm9jZXNzYSBtw7psdGlwbGFzIG1lbnNhZ2VucyBzZSB2aWVyZW0gZW0gYXJyYXlcclxuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGV4dHJhY3RNZXNzYWdlcyhkYXRhKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TpiBUZW50YXRpdmEgJHthdHRlbXB0ICsgMX0vJHttYXhBdHRlbXB0c306ICR7bWVzc2FnZXMubGVuZ3RofSBtZW5zYWdlbnMgZXh0cmHDrWRhc2ApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBuZXdNZXNzYWdlc0NvdW50ID0gMDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGFtYSBvIGNhbGxiYWNrIHBhcmEgY2FkYSBub3ZhIG1lbnNhZ2VtXHJcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobXNnOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHRyaW1tZWRNc2cgPSBtc2cudHJpbSgpO1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0cmltbWVkTXNnLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAgICAgIWlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UodHJpbW1lZE1zZykgJiZcclxuICAgICAgICAgICAgdHJpbW1lZE1zZy50b0xvd2VyQ2FzZSgpICE9PSBcIm51bGxcIiAmJlxyXG4gICAgICAgICAgICB0cmltbWVkTXNnLnRvTG93ZXJDYXNlKCkgIT09IFwidW5kZWZpbmVkXCIgJiZcclxuICAgICAgICAgICAgIXJlY2VpdmVkTWVzc2FnZXMuaGFzKHRyaW1tZWRNc2cpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgcmVjZWl2ZWRNZXNzYWdlcy5hZGQodHJpbW1lZE1zZyk7XHJcbiAgICAgICAgICAgIG5ld01lc3NhZ2VzQ291bnQrKztcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBOb3ZhIG1lbnNhZ2VtICR7bmV3TWVzc2FnZXNDb3VudH0gcmVjZWJpZGEgbmEgdGVudGF0aXZhICR7YXR0ZW1wdCArIDF9OmAsIHRyaW1tZWRNc2cuc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgICAgICAgICBvbk5ld01lc3NhZ2UodHJpbW1lZE1zZyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2UgcmVjZWJldSBub3ZhcyBtZW5zYWdlbnMsIHJlc2V0YSBvIGNvbnRhZG9yIGRlIHRlbnRhdGl2YXMgdmF6aWFzXHJcbiAgICAgICAgaWYgKG5ld01lc3NhZ2VzQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICBjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk4ogVG90YWwgZGUgbWVuc2FnZW5zIHJlY2ViaWRhcyBhdMOpIGFnb3JhOiAke3JlY2VpdmVkTWVzc2FnZXMuc2l6ZX1gKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc2VjdXRpdmVFbXB0eUF0dGVtcHRzKys7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4o+zIFRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfS8ke21heEF0dGVtcHRzfTogU2VtIG5vdmFzIG1lbnNhZ2VucyAoJHtjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHN9LyR7ZW1wdHlBdHRlbXB0c1RvU3RvcH0gdGVudGF0aXZhcyB2YXppYXMgY29uc2VjdXRpdmFzKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBQYXJhIG8gcG9sbGluZyBzZSBuw6NvIGhvdXZlciBub3ZhcyBtZW5zYWdlbnMgcG9yIHbDoXJpYXMgdGVudGF0aXZhcyBjb25zZWN1dGl2YXNcclxuICAgICAgICBpZiAoY29uc2VjdXRpdmVFbXB0eUF0dGVtcHRzID49IGVtcHR5QXR0ZW1wdHNUb1N0b3ApIHtcclxuICAgICAgICAgIGlmIChyZWNlaXZlZE1lc3NhZ2VzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDij7nvuI8gUGFyYW5kbyBwb2xsaW5nOiAke2VtcHR5QXR0ZW1wdHNUb1N0b3B9IHRlbnRhdGl2YXMgY29uc2VjdXRpdmFzIHNlbSBub3ZhcyBtZW5zYWdlbnMuIFRvdGFsOiAke3JlY2VpdmVkTWVzc2FnZXMuc2l6ZX0gbWVuc2FnZW5zIHJlY2ViaWRhc2ApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ZW1wdCA+PSA1KSB7XHJcbiAgICAgICAgICAgIC8vIFNlIG7Do28gcmVjZWJldSBuZW5odW1hIG1lbnNhZ2VtIGFww7NzIDUgdGVudGF0aXZhcywgdGFtYsOpbSBwYXJhXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDij7nvuI8gUGFyYW5kbyBwb2xsaW5nOiBOZW5odW1hIG1lbnNhZ2VtIHJlY2ViaWRhIGFww7NzICR7YXR0ZW1wdCArIDF9IHRlbnRhdGl2YXNgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfTogU3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBFcnJvIG5hIHRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfSBkZSBwb2xsaW5nOmAsIGVycm9yKTtcclxuICAgICAgLy8gQ29udGludWEgdGVudGFuZG8gbWVzbW8gY29tIGVycm9cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGhhc01lc3NhZ2VzID0gcmVjZWl2ZWRNZXNzYWdlcy5zaXplID4gMDtcclxuICBpZiAoIWhhc01lc3NhZ2VzKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYOKPse+4jyBUaW1lb3V0OiBOw6NvIGZvaSBwb3Nzw612ZWwgb2J0ZXIgbWVuc2FnZW5zIGFww7NzICR7bWF4QXR0ZW1wdHN9IHRlbnRhdGl2YXNgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS5sb2coYOKchSBQb2xsaW5nIGZpbmFsaXphZG8uIFRvdGFsIGRlICR7cmVjZWl2ZWRNZXNzYWdlcy5zaXplfSBtZW5zYWdlbnMgcmVjZWJpZGFzYCk7XHJcbiAgfVxyXG4gIHJldHVybiBoYXNNZXNzYWdlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhaSBtw7psdGlwbGFzIG1lbnNhZ2VucyBkbyBmb3JtYXRvIHJldG9ybmFkbyBwZWxvIE44TlxyXG4gKiBTdXBvcnRhIGFycmF5cyBkZSBtZW5zYWdlbnMgb3UgbWVuc2FnZW0gw7puaWNhXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMoZGF0YTogYW55KTogc3RyaW5nW10ge1xyXG4gIGNvbnNvbGUubG9nKFwi8J+UjSBleHRyYWN0TWVzc2FnZXMgY2hhbWFkbyBjb206XCIsIHR5cGVvZiBkYXRhLCBBcnJheS5pc0FycmF5KGRhdGEpID8gYGFycmF5WyR7ZGF0YS5sZW5ndGh9XWAgOiBkYXRhKTtcclxuICBcclxuICAvLyBTZSBmb3Igc3RyaW5nLCB0ZW50YSBwYXJzZWFyIGNvbW8gSlNPTlxyXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgcmV0dXJuIGV4dHJhY3RNZXNzYWdlcyhwYXJzZWQpO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIFNlIG7Do28gZm9yIEpTT04gdsOhbGlkbywgcmV0b3JuYSBjb21vIGFycmF5IGNvbSB1bWEgbWVuc2FnZW1cclxuICAgICAgcmV0dXJuIGRhdGEudHJpbSgpID8gW2RhdGFdIDogW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTZSBmb3IgdW0gYXJyYXksIHByb2Nlc3NhIGNhZGEgaXRlbVxyXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TpiBQcm9jZXNzYW5kbyBhcnJheSBjb20gJHtkYXRhLmxlbmd0aH0gaXRlbnNgKTtcclxuICAgIGNvbnN0IG1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZGF0YS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBQcm9jZXNzYW5kbyBpdGVtICR7aW5kZXggKyAxfS8ke2RhdGEubGVuZ3RofTpgLCBpdGVtKTtcclxuICAgICAgY29uc3QgZXh0cmFjdGVkID0gZXh0cmFjdFJlc3BvbnNlKGl0ZW0pO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBJdGVtICR7aW5kZXggKyAxfSBleHRyYcOtZG86YCwgZXh0cmFjdGVkPy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgIGlmIChleHRyYWN0ZWQgJiYgZXh0cmFjdGVkLnRyaW0oKSkge1xyXG4gICAgICAgIG1lc3NhZ2VzLnB1c2goZXh0cmFjdGVkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gSXRlbSAke2luZGV4ICsgMX0gbsOjbyB0aW5oYSBjb250ZcO6ZG8gdsOhbGlkb2ApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKGDinIUgVG90YWwgZGUgJHttZXNzYWdlcy5sZW5ndGh9IG1lbnNhZ2VucyBleHRyYcOtZGFzIGRvIGFycmF5YCk7XHJcbiAgICByZXR1cm4gbWVzc2FnZXM7XHJcbiAgfVxyXG5cclxuICAvLyBTZSBmb3Igb2JqZXRvLCBleHRyYWkgYSBtZW5zYWdlbVxyXG4gIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBjb25zdCBleHRyYWN0ZWQgPSBleHRyYWN0UmVzcG9uc2UoZGF0YSk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBPYmpldG8gZXh0cmHDrWRvOmAsIGV4dHJhY3RlZD8uc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgcmV0dXJuIGV4dHJhY3RlZCAmJiBleHRyYWN0ZWQudHJpbSgpID8gW2V4dHJhY3RlZF0gOiBbXTtcclxuICAgIH1cclxuXHJcbiAgY29uc29sZS5sb2coXCLimqDvuI8gVGlwbyBkZSBkYWRvcyBuw6NvIHJlY29uaGVjaWRvLCByZXRvcm5hbmRvIGFycmF5IHZhemlvXCIpO1xyXG4gIHJldHVybiBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVudmlhIHVtYSBtZW5zYWdlbSBwYXJhIG8gd2ViaG9vayBOOE4gZSByZWNlYmUgbcO6bHRpcGxhcyBtZW5zYWdlbnMgc2VwYXJhZGFzXHJcbiAqIFNlIGEgcmVzcG9zdGEgaW5pY2lhbCBmb3IgXCJ3b3JrZmxvdyBpbmljaWFkb1wiLCBmYXogcG9sbGluZyBhdMOpIHJlY2ViZXIgYXMgbWVuc2FnZW5zXHJcbiAqIEBwYXJhbSBtZXNzYWdlIC0gQSBtZW5zYWdlbSBkbyB1c3XDoXJpb1xyXG4gKiBAcGFyYW0gYWdlbnRUeXBlIC0gVGlwbyBkbyBhZ2VudGUgSUEgKHNkciwgZWNvbW1lcmNlLCBhZ2VuZGFtZW50bylcclxuICogQHBhcmFtIG9uTmV3TWVzc2FnZSAtIENhbGxiYWNrIGNoYW1hZG8gcGFyYSBjYWRhIG5vdmEgbWVuc2FnZW0gcmVjZWJpZGEgZGEgSUFcclxuICogQHBhcmFtIG9uUG9sbGluZyAtIENhbGxiYWNrIGNoYW1hZG8gZHVyYW50ZSBvIHBvbGxpbmcgKHBhcmEgYW5pbWHDp8OjbylcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZVRvV2ViaG9vayhcclxuICBtZXNzYWdlOiBzdHJpbmcsXHJcbiAgYWdlbnRUeXBlOiBBZ2VudFR5cGUsXHJcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXHJcbiAgb25OZXdNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxyXG4gIG9uUG9sbGluZz86IChpc1BvbGxpbmc6IGJvb2xlYW4pID0+IHZvaWRcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghc2Vzc2lvbklkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlc3Npb25JZCDDqSBvYnJpZ2F0w7NyaW8gcGFyYSBlbnZpYXIgbWVuc2FnZW5zXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBheWxvYWQ6IFdlYmhvb2tNZXNzYWdlID0ge1xyXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLnRyaW0oKSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLFxyXG4gICAgICBhZ2VudFR5cGU6IGFnZW50VHlwZSxcclxuICAgIH07XHJcblxyXG4gICAgLy8gTG9nIHBhcmEgZGVidWdcclxuICAgIGNvbnNvbGUubG9nKFwiRW52aWFuZG8gbWVuc2FnZW0gcGFyYSB3ZWJob29rOlwiLCB7XHJcbiAgICAgIHVybDogV0VCSE9PS19VUkwsXHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIHBheWxvYWQ6IHBheWxvYWQsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFdFQkhPT0tfVVJMLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIlJlc3Bvc3RhIGRvIHdlYmhvb2s6XCIsIHtcclxuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXHJcbiAgICAgIG9rOiByZXNwb25zZS5vayxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IHJlc3BvbnNlLnN0YXR1c1RleHQpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBuYSByZXNwb3N0YSBkbyB3ZWJob29rOlwiLCB7XHJcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXHJcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcclxuICAgICAgICBib2R5OiBlcnJvclRleHQsXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm8gSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZW50YSBwYXJzZWFyIGNvbW8gSlNPTiwgbWFzIHRhbWLDqW0gc3Vwb3J0YSB0ZXh0byBzaW1wbGVzXHJcbiAgICBsZXQgZGF0YTogV2ViaG9va1Jlc3BvbnNlIHwgc3RyaW5nO1xyXG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xyXG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgICBkYXRhID0gdGV4dDtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBwYXJzZWFyIHJlc3Bvc3RhOlwiLCBwYXJzZUVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJybyBhbyBwcm9jZXNzYXIgcmVzcG9zdGEgZG8gd2ViaG9va1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkRhZG9zIHBhcnNlYWRvczpcIiwgZGF0YSk7XHJcblxyXG4gICAgLy8gRXh0cmFpIGFzIG1lbnNhZ2VucyBkbyBmb3JtYXRvIHJldG9ybmFkbyBwZWxvIE44TlxyXG4gICAgY29uc3QgbWVzc2FnZXMgPSBleHRyYWN0TWVzc2FnZXMoZGF0YSk7XHJcbiAgICBjb25zb2xlLmxvZyhcIk1lbnNhZ2VucyBleHRyYcOtZGFzOlwiLCBtZXNzYWdlcyk7XHJcbiAgICBcclxuICAgIC8vIFZlcmlmaWNhIHNlIG8gd29ya2Zsb3cgZm9pIGluaWNpYWRvIChpbmRpY2EgcXVlIG1haXMgbWVuc2FnZW5zIHBvZGVtIHZpcilcclxuICAgIGNvbnN0IGlzV29ya2Zsb3dTdGFydGVkID0gbWVzc2FnZXMuc29tZShtc2cgPT4gaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZShtc2cpKTtcclxuICAgIGNvbnN0IHZhbGlkTWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIobXNnID0+ICFpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKG1zZykpO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBXb3JrZmxvdyBpbmljaWFkbz8gJHtpc1dvcmtmbG93U3RhcnRlZH0sIE1lbnNhZ2VucyB2w6FsaWRhcyBuYSByZXNwb3N0YSBpbmljaWFsOiAke3ZhbGlkTWVzc2FnZXMubGVuZ3RofWApO1xyXG4gICAgXHJcbiAgICAvLyBQcm9jZXNzYSBtZW5zYWdlbnMgZGEgcmVzcG9zdGEgaW5pY2lhbCBwcmltZWlybyAoc2UgaG91dmVyKVxyXG4gICAgaWYgKHZhbGlkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TqCBQcm9jZXNzYW5kbyAke3ZhbGlkTWVzc2FnZXMubGVuZ3RofSBtZW5zYWdlbnMgZGEgcmVzcG9zdGEgaW5pY2lhbGApO1xyXG4gICAgICB2YWxpZE1lc3NhZ2VzLmZvckVhY2goKG1zZywgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TpCBFbnZpYW5kbyBtZW5zYWdlbSAke2luZGV4ICsgMX0vJHt2YWxpZE1lc3NhZ2VzLmxlbmd0aH0gZGEgcmVzcG9zdGEgaW5pY2lhbDpgLCBtc2cuc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgICAgIG9uTmV3TWVzc2FnZShtc2cpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgQ2FsbGJhY2sgb25OZXdNZXNzYWdlIGNoYW1hZG8gcGFyYSBtZW5zYWdlbSAke2luZGV4ICsgMX1gKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgVG9kYXMgYXMgJHt2YWxpZE1lc3NhZ2VzLmxlbmd0aH0gbWVuc2FnZW5zIGRhIHJlc3Bvc3RhIGluaWNpYWwgZm9yYW0gZW52aWFkYXNgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gTmVuaHVtYSBtZW5zYWdlbSB2w6FsaWRhIGVuY29udHJhZGEgbmEgcmVzcG9zdGEgaW5pY2lhbGApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZW1wcmUgZmF6ZW1vcyBwb2xsaW5nIG5hIEFQSSBpbnRlcm5hIGRlIG1lbnNhZ2VucyBwYXJhIHRyYXplciBhcyByZXNwb3N0YXMgcXVlIG8gZmx1eG8gZW52aW91IHZpYSBIVFRQIFJlcXVlc3QxXHJcbiAgICBjb25zb2xlLmxvZyhcIvCflIQgSW5pY2lhbmRvIHBvbGxpbmcgbmEgQVBJIGludGVybmEgL2FwaS9jaGF0L21lc3NhZ2VzIHBhcmEgYnVzY2FyIHJlc3Bvc3RhcyBkbyBmbHV4b1wiKTtcclxuICAgIGlmIChvblBvbGxpbmcpIG9uUG9sbGluZyh0cnVlKTtcclxuICAgIGF3YWl0IHBvbGxDaGF0TWVzc2FnZXMoc2Vzc2lvbklkLCBvbk5ld01lc3NhZ2UsIHZhbGlkTWVzc2FnZXMpO1xyXG4gICAgaWYgKG9uUG9sbGluZykgb25Qb2xsaW5nKGZhbHNlKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm8gY29tcGxldG8gYW8gZW52aWFyIG1lbnNhZ2VtIHBhcmEgd2ViaG9vazpcIiwge1xyXG4gICAgICBlcnJvcixcclxuICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkVycm8gZGVzY29uaGVjaWRvXCIsXHJcbiAgICAgIHN0YWNrOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiB1bmRlZmluZWQsXHJcbiAgICB9KTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZheiBwb2xsaW5nIG5hIEFQSSBpbnRlcm5hICgvYXBpL2NoYXQvbWVzc2FnZXMpIHBhcmEgYnVzY2FyIG1lbnNhZ2VucyBwZXJzaXN0aWRhcyBwZWxvIGZsdXhvXHJcbiAqL1xyXG4vLyBOb3JtYWxpemEgbWVuc2FnZW0gcGFyYSBjb21wYXJhw6fDo28gKHJlbW92ZSBlc3Bhw6dvcyBleHRyYXMsIHF1ZWJyYXMgZGUgbGluaGEsIGV0YylcclxuZnVuY3Rpb24gbm9ybWFsaXplTWVzc2FnZShtc2c6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIG1zZy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHBvbGxDaGF0TWVzc2FnZXMoXHJcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXHJcbiAgb25OZXdNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxyXG4gIGluaXRpYWxNZXNzYWdlczogc3RyaW5nW10gPSBbXSxcclxuICBtYXhBdHRlbXB0czogbnVtYmVyID0gODAsICAgICAgICAgIC8vIH4xNjBzIG5vIHBpb3IgY2FzbyAoODAgKiAycylcclxuICBpbnRlcnZhbE1zOiBudW1iZXIgPSAyMDAwLCAgICAgICAgIC8vIDJzIGVudHJlIHRlbnRhdGl2YXNcclxuICBlbXB0eUF0dGVtcHRzVG9TdG9wOiBudW1iZXIgPSA4LCAgIC8vIHBhcmEgYXDDs3MgOCB0ZW50YXRpdmFzIHZhemlhcyBzZWd1aWRhc1xyXG4gIG1pbkF0dGVtcHRzQmVmb3JlU3RvcDogbnVtYmVyID0gNiAgLy8gZ2FyYW50ZSBhbyBtZW5vcyA2IHRlbnRhdGl2YXMgYW50ZXMgZGUgcGFyYXJcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgbGV0IGN1cnNvciA9IC0xO1xyXG4gIGxldCBjb25zZWN1dGl2ZUVtcHR5ID0gMDtcclxuICAvLyBVc2Egbm9ybWFsaXphw6fDo28gcGFyYSBjb21wYXJhw6fDo28gZGUgbWVuc2FnZW5zXHJcbiAgY29uc3QgcmVjZWl2ZWQgPSBuZXcgU2V0PHN0cmluZz4oaW5pdGlhbE1lc3NhZ2VzLm1hcChub3JtYWxpemVNZXNzYWdlKSk7XHJcblxyXG4gIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xyXG4gICAgLy8gZXNwZXJhIGVudHJlIHRlbnRhdGl2YXMsIGV4Y2V0byBuYSBwcmltZWlyYVxyXG4gICAgaWYgKGF0dGVtcHQgPiAwKSB7XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIGludGVydmFsTXMpKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB1cmwgPSBgJHtDSEFUX0FQSV9VUkx9P3Nlc3Npb25JZD0ke2VuY29kZVVSSUNvbXBvbmVudChzZXNzaW9uSWQpfSZjdXJzb3I9JHtjdXJzb3J9YDtcclxuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKHVybCwgeyBtZXRob2Q6IFwiR0VUXCIgfSk7XHJcbiAgICAgIGlmICghcmVzcC5vaykge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFBvbGxpbmcgY2hhdCBBUEkgc3RhdHVzICR7cmVzcC5zdGF0dXN9IG5hIHRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfWApO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcC5qc29uKCk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VzOiB7IHRleHQ/OiBzdHJpbmcgfVtdID0gZGF0YT8ubWVzc2FnZXMgPz8gW107XHJcbiAgICAgIGNvbnN0IGxhc3RJZHg6IG51bWJlciA9IHR5cGVvZiBkYXRhPy5sYXN0SWR4ID09PSBcIm51bWJlclwiID8gZGF0YS5sYXN0SWR4IDogY3Vyc29yO1xyXG5cclxuICAgICAgbGV0IG5ld0NvdW50ID0gMDtcclxuICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHR4dCA9IChtPy50ZXh0ID8/IFwiXCIpLnRyaW0oKTtcclxuICAgICAgICBpZiAodHh0ICYmICFyZWNlaXZlZC5oYXModHh0KSAmJiAhaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZSh0eHQpICYmIHR4dC50b0xvd2VyQ2FzZSgpICE9PSBcIm51bGxcIikge1xyXG4gICAgICAgICAgcmVjZWl2ZWQuYWRkKHR4dCk7XHJcbiAgICAgICAgICBuZXdDb3VudCsrO1xyXG4gICAgICAgICAgb25OZXdNZXNzYWdlKHR4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChuZXdDb3VudCA+IDApIHtcclxuICAgICAgICBjdXJzb3IgPSBsYXN0SWR4O1xyXG4gICAgICAgIGNvbnNlY3V0aXZlRW1wdHkgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNlY3V0aXZlRW1wdHkrKztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNvbnNlY3V0aXZlRW1wdHkgPj0gZW1wdHlBdHRlbXB0c1RvU3RvcCAmJiBhdHRlbXB0ICsgMSA+PSBtaW5BdHRlbXB0c0JlZm9yZVN0b3ApIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEVycm8gYW8gZmF6ZXIgcG9sbGluZyBkYSBjaGF0IEFQSSBuYSB0ZW50YXRpdmEgJHthdHRlbXB0ICsgMX06YCwgZXJyKTtcclxuICAgICAgLy8gY29udGludWEgdGVudGFuZG9cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWkgYSByZXNwb3N0YSBkbyBmb3JtYXRvIHJldG9ybmFkbyBwZWxvIE44TlxyXG4gKiBTdXBvcnRhIGRpZmVyZW50ZXMgZm9ybWF0b3MgZGUgcmVzcG9zdGEsIGluY2x1aW5kbyBhcnJheXMgSlNPTlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlKGRhdGE6IFdlYmhvb2tSZXNwb25zZSB8IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgLy8gU2UgZm9yIHN0cmluZywgdGVudGEgcGFyc2VhciBjb21vIEpTT04gcHJpbWVpcm9cclxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIC8vIFRlbnRhIHBhcnNlYXIgY29tbyBKU09OXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAvLyBTZSBwYXJzZW91IGNvbSBzdWNlc3NvLCBwcm9jZXNzYSBvIG9iamV0by9hcnJheVxyXG4gICAgICByZXR1cm4gZXh0cmFjdFJlc3BvbnNlKHBhcnNlZCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gU2UgbsOjbyBmb3IgSlNPTiB2w6FsaWRvLCByZXRvcm5hIGEgc3RyaW5nIGNvbW8gZXN0w6FcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTZSBmb3IgdW0gYXJyYXksIHBlZ2EgbyBwcmltZWlybyBlbGVtZW50b1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgZmlyc3RJdGVtID0gZGF0YVswXTtcclxuICAgIC8vIFNlIG8gcHJpbWVpcm8gaXRlbSB0aXZlciBjYW1wbyBcIm91dHB1dFwiLCByZXRvcm5hIGVsZVxyXG4gICAgaWYgKGZpcnN0SXRlbSAmJiB0eXBlb2YgZmlyc3RJdGVtID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gZmlyc3RJdGVtKSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoZmlyc3RJdGVtLm91dHB1dCB8fCBcIlwiKTtcclxuICAgIH1cclxuICAgIC8vIFNlIG7Do28sIHRlbnRhIGV4dHJhaXIgZG8gcHJpbWVpcm8gaXRlbVxyXG4gICAgcmV0dXJuIGV4dHJhY3RSZXNwb25zZShmaXJzdEl0ZW0pO1xyXG4gIH1cclxuXHJcbiAgLy8gU2UgZm9yIG9iamV0bywgdGVudGEgZGlmZXJlbnRlcyBjYW1wb3MgY29tdW5zIGRlIHJlc3Bvc3RhXHJcbiAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIC8vIFByaW9yaXphIG8gY2FtcG8gXCJ0ZXh0XCIgKGZvcm1hdG8gY29tdW0gZG8gTjhOKVxyXG4gICAgaWYgKFwidGV4dFwiIGluIGRhdGEgJiYgZGF0YS50ZXh0KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIENhbXBvIFwidGV4dFwiIGVuY29udHJhZG86YCwgU3RyaW5nKGRhdGEudGV4dCkuc3Vic3RyaW5nKDAsIDEwMCkpO1xyXG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGEudGV4dCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFByaW9yaXphIG8gY2FtcG8gXCJvdXRwdXRcIiBzZSBleGlzdGlyXHJcbiAgICBpZiAoXCJvdXRwdXRcIiBpbiBkYXRhICYmIGRhdGEub3V0cHV0KSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUZW50YSBvdXRyb3MgY2FtcG9zIGNvbXVuc1xyXG4gICAgaWYgKGRhdGEucmVzcG9uc2UpIHJldHVybiBTdHJpbmcoZGF0YS5yZXNwb25zZSk7XHJcbiAgICBpZiAoZGF0YS5tZXNzYWdlKSByZXR1cm4gU3RyaW5nKGRhdGEubWVzc2FnZSk7XHJcbiAgICBcclxuICAgIC8vIFRlbnRhIGNhbXBvcyBhbmluaGFkb3NcclxuICAgIGlmIChkYXRhLm91dHB1dCAmJiB0eXBlb2YgZGF0YS5vdXRwdXQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGRhdGEub3V0cHV0KSByZXR1cm4gU3RyaW5nKGRhdGEub3V0cHV0Lm1lc3NhZ2UpO1xyXG4gICAgICBpZiAoXCJyZXNwb25zZVwiIGluIGRhdGEub3V0cHV0KSByZXR1cm4gU3RyaW5nKGRhdGEub3V0cHV0LnJlc3BvbnNlKTtcclxuICAgICAgaWYgKFwidGV4dFwiIGluIGRhdGEub3V0cHV0KSByZXR1cm4gU3RyaW5nKGRhdGEub3V0cHV0LnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU2UgbsOjbyBlbmNvbnRyYXIgbmVuaHVtIGNhbXBvIGNvbmhlY2lkbywgcmV0b3JuYSBvIEpTT04gc3RyaW5naWZpY2Fkb1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbIldFQkhPT0tfVVJMIiwiQ0hBVF9BUElfVVJMIiwiY3JlYXRlU2Vzc2lvbklkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIldPUktGTE9XX1NUQVJURURfTUVTU0FHRVMiLCJpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlIiwicmVzcG9uc2UiLCJsb3dlclJlc3BvbnNlIiwidG9Mb3dlckNhc2UiLCJzb21lIiwibXNnIiwiaW5jbHVkZXMiLCJwb2xsRm9yTWVzc2FnZXMiLCJzZXNzaW9uSWQiLCJvbk5ld01lc3NhZ2UiLCJpbml0aWFsTWVzc2FnZXMiLCJtYXhBdHRlbXB0cyIsImludGVydmFsTXMiLCJlbXB0eUF0dGVtcHRzVG9TdG9wIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsInJlY2VpdmVkTWVzc2FnZXMiLCJTZXQiLCJjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMiLCJhdHRlbXB0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjaGVja1N0YXR1cyIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwib2siLCJjb250ZW50VHlwZSIsImdldCIsImRhdGEiLCJqc29uIiwidGV4dCIsIm1lc3NhZ2VzIiwiZXh0cmFjdE1lc3NhZ2VzIiwibmV3TWVzc2FnZXNDb3VudCIsImZvckVhY2giLCJ0cmltbWVkTXNnIiwidHJpbSIsImhhcyIsImFkZCIsInNpemUiLCJ3YXJuIiwic3RhdHVzIiwiZXJyb3IiLCJoYXNNZXNzYWdlcyIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlZCIsInBhcnNlIiwiaXRlbSIsImluZGV4IiwiZXh0cmFjdGVkIiwiZXh0cmFjdFJlc3BvbnNlIiwicHVzaCIsInNlbmRNZXNzYWdlVG9XZWJob29rIiwibWVzc2FnZSIsImFnZW50VHlwZSIsIm9uUG9sbGluZyIsIkVycm9yIiwicGF5bG9hZCIsInVybCIsInN0YXR1c1RleHQiLCJlcnJvclRleHQiLCJjYXRjaCIsInBhcnNlRXJyb3IiLCJpc1dvcmtmbG93U3RhcnRlZCIsInZhbGlkTWVzc2FnZXMiLCJmaWx0ZXIiLCJwb2xsQ2hhdE1lc3NhZ2VzIiwic3RhY2siLCJ1bmRlZmluZWQiLCJub3JtYWxpemVNZXNzYWdlIiwicmVwbGFjZSIsIm1pbkF0dGVtcHRzQmVmb3JlU3RvcCIsImN1cnNvciIsImNvbnNlY3V0aXZlRW1wdHkiLCJyZWNlaXZlZCIsIm1hcCIsInIiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXNwIiwibGFzdElkeCIsIm5ld0NvdW50IiwibSIsInR4dCIsImVyciIsImZpcnN0SXRlbSIsIlN0cmluZyIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/webhookService.ts\n"));

/***/ })

});