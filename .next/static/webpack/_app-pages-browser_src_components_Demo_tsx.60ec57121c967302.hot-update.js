"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_components_Demo_tsx",{

/***/ "(app-pages-browser)/./src/services/webhookService.ts":
/*!****************************************!*\
  !*** ./src/services/webhookService.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSessionId: function() { return /* binding */ createSessionId; },\n/* harmony export */   isWorkflowStartedResponse: function() { return /* binding */ isWorkflowStartedResponse; },\n/* harmony export */   sendMessageToWebhook: function() { return /* binding */ sendMessageToWebhook; }\n/* harmony export */ });\n/**\r\n * Serviço para comunicação com o webhook N8N\r\n */ const WEBHOOK_URL = \"https://webhook.agentemwd.com/webhook/9de471bd-4296-4cc8-bc40-f2ea1d19f6dd\";\nconst CHAT_API_URL = \"/api/chat/messages\";\n/**\r\n * Gera um ID único para a sessão ou recupera o existente do sessionStorage\r\n * O ID é único por sessão do navegador (recarrega quando a página é recarregada)\r\n * @returns ID único da sessão\r\n */ function createSessionId() {\n    return \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substring(2, 15));\n}\n// Mensagens que indicam que o workflow foi iniciado mas ainda não há resposta\nconst WORKFLOW_STARTED_MESSAGES = [\n    \"workflow foi iniciado\",\n    \"workflow iniciado\",\n    \"workflow started\",\n    \"processando\",\n    \"processando sua mensagem\",\n    \"aguarde\",\n    \"workflow was started\"\n];\n/**\r\n * Verifica se a resposta indica que o workflow foi iniciado mas ainda não há resposta final\r\n */ function isWorkflowStartedResponse(response) {\n    const lowerResponse = response.toLowerCase();\n    return WORKFLOW_STARTED_MESSAGES.some((msg)=>lowerResponse.includes(msg));\n}\n/**\r\n * Faz polling para verificar se há mensagens disponíveis\r\n * IMPORTANTE: Apenas verifica status, NÃO inicia novas execuções\r\n * @param sessionId - ID da sessão\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida\r\n * @param maxAttempts - Número máximo de tentativas (padrão: 30 = 60 segundos)\r\n * @param intervalMs - Intervalo entre tentativas em ms (padrão: 2000 = 2 segundos)\r\n * @param emptyAttemptsToStop - Número de tentativas vazias consecutivas para parar (padrão: 2)\r\n * @returns true se recebeu mensagens, false se timeout\r\n */ async function pollForMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 30, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;\n    console.log(\"\\uD83D\\uDD04 Iniciando polling APENAS para verificar status. SessionId: \".concat(sessionId, \", m\\xe1ximo \").concat(maxAttempts, \" tentativas\"));\n    console.log(\"\\uD83D\\uDCCB Mensagens j\\xe1 recebidas na primeira resposta: \".concat(initialMessages.length));\n    const receivedMessages = new Set(initialMessages); // Inclui mensagens já recebidas para evitar duplicatas\n    let consecutiveEmptyAttempts = 0; // Contador de tentativas consecutivas sem novas mensagens\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // Aguarda antes de fazer a próxima tentativa (exceto na primeira)\n        if (attempt > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, intervalMs));\n        }\n        try {\n            // IMPORTANTE: Apenas verifica status, NÃO envia mensagem nem agentType\n            // Isso evita iniciar novas execuções do workflow\n            const response = await fetch(WEBHOOK_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    sessionId: sessionId,\n                    checkStatus: true,\n                    timestamp: new Date().toISOString()\n                })\n            });\n            if (response.ok) {\n                const contentType = response.headers.get(\"content-type\");\n                let data;\n                if (contentType && contentType.includes(\"application/json\")) {\n                    data = await response.json();\n                } else {\n                    const text = await response.text();\n                    data = text;\n                }\n                // Processa múltiplas mensagens se vierem em array\n                const messages = extractMessages(data);\n                console.log(\"\\uD83D\\uDCE6 Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": \").concat(messages.length, \" mensagens extra\\xeddas\"));\n                let newMessagesCount = 0;\n                // Chama o callback para cada nova mensagem\n                messages.forEach((msg)=>{\n                    const trimmedMsg = msg.trim();\n                    if (trimmedMsg.length > 0 && !isWorkflowStartedResponse(trimmedMsg) && trimmedMsg.toLowerCase() !== \"null\" && trimmedMsg.toLowerCase() !== \"undefined\" && !receivedMessages.has(trimmedMsg)) {\n                        receivedMessages.add(trimmedMsg);\n                        newMessagesCount++;\n                        console.log(\"✅ Nova mensagem \".concat(newMessagesCount, \" recebida na tentativa \").concat(attempt + 1, \":\"), trimmedMsg.substring(0, 100));\n                        onNewMessage(trimmedMsg);\n                    }\n                });\n                // Se recebeu novas mensagens, reseta o contador de tentativas vazias\n                if (newMessagesCount > 0) {\n                    consecutiveEmptyAttempts = 0;\n                    console.log(\"\\uD83D\\uDCCA Total de mensagens recebidas at\\xe9 agora: \".concat(receivedMessages.size));\n                } else {\n                    consecutiveEmptyAttempts++;\n                    console.log(\"⏳ Tentativa \".concat(attempt + 1, \"/\").concat(maxAttempts, \": Sem novas mensagens (\").concat(consecutiveEmptyAttempts, \"/\").concat(emptyAttemptsToStop, \" tentativas vazias consecutivas)\"));\n                }\n                // Para o polling se não houver novas mensagens por várias tentativas consecutivas\n                if (consecutiveEmptyAttempts >= emptyAttemptsToStop) {\n                    if (receivedMessages.size > 0) {\n                        console.log(\"⏹️ Parando polling: \".concat(emptyAttemptsToStop, \" tentativas consecutivas sem novas mensagens. Total: \").concat(receivedMessages.size, \" mensagens recebidas\"));\n                        break;\n                    } else if (attempt >= 5) {\n                        // Se não recebeu nenhuma mensagem após 5 tentativas, também para\n                        console.log(\"⏹️ Parando polling: Nenhuma mensagem recebida ap\\xf3s \".concat(attempt + 1, \" tentativas\"));\n                        break;\n                    }\n                }\n            } else {\n                console.warn(\"⚠️ Tentativa \".concat(attempt + 1, \": Status \").concat(response.status));\n            }\n        } catch (error) {\n            console.warn(\"⚠️ Erro na tentativa \".concat(attempt + 1, \" de polling:\"), error);\n        // Continua tentando mesmo com erro\n        }\n    }\n    const hasMessages = receivedMessages.size > 0;\n    if (!hasMessages) {\n        console.warn(\"⏱️ Timeout: N\\xe3o foi poss\\xedvel obter mensagens ap\\xf3s \".concat(maxAttempts, \" tentativas\"));\n    } else {\n        console.log(\"✅ Polling finalizado. Total de \".concat(receivedMessages.size, \" mensagens recebidas\"));\n    }\n    return hasMessages;\n}\n/**\r\n * Extrai múltiplas mensagens do formato retornado pelo N8N\r\n * Suporta arrays de mensagens ou mensagem única\r\n */ function extractMessages(data) {\n    console.log(\"\\uD83D\\uDD0D extractMessages chamado com:\", typeof data, Array.isArray(data) ? \"array[\".concat(data.length, \"]\") : data);\n    // Se for string, tenta parsear como JSON\n    if (typeof data === \"string\") {\n        try {\n            const parsed = JSON.parse(data);\n            return extractMessages(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna como array com uma mensagem\n            return data.trim() ? [\n                data\n            ] : [];\n        }\n    }\n    // Se for um array, processa cada item\n    if (Array.isArray(data)) {\n        console.log(\"\\uD83D\\uDCE6 Processando array com \".concat(data.length, \" itens\"));\n        const messages = [];\n        data.forEach((item, index)=>{\n            console.log(\"\\uD83D\\uDD0D Processando item \".concat(index + 1, \"/\").concat(data.length, \":\"), item);\n            const extracted = extractResponse(item);\n            console.log(\"\\uD83D\\uDCDD Item \".concat(index + 1, \" extra\\xeddo:\"), extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n            if (extracted && extracted.trim()) {\n                messages.push(extracted);\n            } else {\n                console.log(\"⚠️ Item \".concat(index + 1, \" n\\xe3o tinha conte\\xfado v\\xe1lido\"));\n            }\n        });\n        console.log(\"✅ Total de \".concat(messages.length, \" mensagens extra\\xeddas do array\"));\n        return messages;\n    }\n    // Se for objeto, extrai a mensagem\n    if (data && typeof data === \"object\") {\n        const extracted = extractResponse(data);\n        console.log(\"\\uD83D\\uDCDD Objeto extra\\xeddo:\", extracted === null || extracted === void 0 ? void 0 : extracted.substring(0, 100));\n        return extracted && extracted.trim() ? [\n            extracted\n        ] : [];\n    }\n    console.log(\"⚠️ Tipo de dados n\\xe3o reconhecido, retornando array vazio\");\n    return [];\n}\n/**\r\n * Envia uma mensagem para o webhook N8N e recebe múltiplas mensagens separadas\r\n * Se a resposta inicial for \"workflow iniciado\", faz polling até receber as mensagens\r\n * @param message - A mensagem do usuário\r\n * @param agentType - Tipo do agente IA (sdr, ecommerce, agendamento)\r\n * @param onNewMessage - Callback chamado para cada nova mensagem recebida da IA\r\n * @param onPolling - Callback chamado durante o polling (para animação)\r\n */ async function sendMessageToWebhook(message, agentType, sessionId, onNewMessage, onPolling) {\n    try {\n        if (!sessionId) {\n            throw new Error(\"sessionId \\xe9 obrigat\\xf3rio para enviar mensagens\");\n        }\n        const payload = {\n            message: message.trim(),\n            timestamp: new Date().toISOString(),\n            sessionId: sessionId,\n            agentType: agentType\n        };\n        // Log para debug\n        console.log(\"Enviando mensagem para webhook:\", {\n            url: WEBHOOK_URL,\n            method: \"POST\",\n            payload: payload\n        });\n        const response = await fetch(WEBHOOK_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload)\n        });\n        console.log(\"Resposta do webhook:\", {\n            status: response.status,\n            statusText: response.statusText,\n            ok: response.ok\n        });\n        if (!response.ok) {\n            const errorText = await response.text().catch(()=>response.statusText);\n            console.error(\"Erro na resposta do webhook:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(\"Erro HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        // Tenta parsear como JSON, mas também suporta texto simples\n        let data;\n        const contentType = response.headers.get(\"content-type\");\n        try {\n            if (contentType && contentType.includes(\"application/json\")) {\n                data = await response.json();\n            } else {\n                const text = await response.text();\n                data = text;\n            }\n        } catch (parseError) {\n            console.error(\"Erro ao parsear resposta:\", parseError);\n            throw new Error(\"Erro ao processar resposta do webhook\");\n        }\n        console.log(\"Dados parseados:\", data);\n        // Extrai as mensagens do formato retornado pelo N8N\n        const messages = extractMessages(data);\n        console.log(\"Mensagens extra\\xeddas:\", messages);\n        // Verifica se o workflow foi iniciado (indica que mais mensagens podem vir)\n        const isWorkflowStarted = messages.some((msg)=>isWorkflowStartedResponse(msg));\n        const validMessages = messages.filter((msg)=>!isWorkflowStartedResponse(msg));\n        console.log(\"\\uD83D\\uDCCA Workflow iniciado? \".concat(isWorkflowStarted, \", Mensagens v\\xe1lidas na resposta inicial: \").concat(validMessages.length));\n        // Processa mensagens da resposta inicial primeiro (se houver)\n        if (validMessages.length > 0) {\n            console.log(\"\\uD83D\\uDCE8 Processando \".concat(validMessages.length, \" mensagens da resposta inicial\"));\n            validMessages.forEach((msg, index)=>{\n                console.log(\"\\uD83D\\uDCE4 Enviando mensagem \".concat(index + 1, \"/\").concat(validMessages.length, \" da resposta inicial:\"), msg.substring(0, 100));\n                onNewMessage(msg);\n                console.log(\"✅ Callback onNewMessage chamado para mensagem \".concat(index + 1));\n            });\n            console.log(\"✅ Todas as \".concat(validMessages.length, \" mensagens da resposta inicial foram enviadas\"));\n        } else {\n            console.log(\"⚠️ Nenhuma mensagem v\\xe1lida encontrada na resposta inicial\");\n        }\n        // Sempre fazemos polling na API interna de mensagens para trazer as respostas que o fluxo enviou via HTTP Request1\n        console.log(\"\\uD83D\\uDD04 Iniciando polling na API interna /api/chat/messages para buscar respostas do fluxo\");\n        if (onPolling) onPolling(true);\n        await pollChatMessages(sessionId, onNewMessage, validMessages);\n        if (onPolling) onPolling(false);\n    } catch (error) {\n        console.error(\"Erro completo ao enviar mensagem para webhook:\", {\n            error,\n            message: error instanceof Error ? error.message : \"Erro desconhecido\",\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        throw error;\n    }\n}\n/**\r\n * Faz polling na API interna (/api/chat/messages) para buscar mensagens persistidas pelo fluxo\r\n */ // Normaliza mensagem para comparação (remove espaços extras, quebras de linha, etc)\nfunction normalizeMessage(msg) {\n    return msg.trim().replace(/\\s+/g, \" \").toLowerCase();\n}\nasync function pollChatMessages(sessionId, onNewMessage) {\n    let initialMessages = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], maxAttempts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 80, intervalMs = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000, emptyAttemptsToStop = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 8, minAttemptsBeforeStop = arguments.length > 6 && arguments[6] !== void 0 // garante ao menos 6 tentativas antes de parar\n     ? arguments[6] : 6;\n    let cursor = -1;\n    let consecutiveEmpty = 0;\n    // Usa normalização para comparação de mensagens\n    const received = new Set(initialMessages.map(normalizeMessage));\n    for(let attempt = 0; attempt < maxAttempts; attempt++){\n        // espera entre tentativas, exceto na primeira\n        if (attempt > 0) {\n            await new Promise((r)=>setTimeout(r, intervalMs));\n        }\n        try {\n            const url = \"\".concat(CHAT_API_URL, \"?sessionId=\").concat(encodeURIComponent(sessionId), \"&cursor=\").concat(cursor);\n            const resp = await fetch(url, {\n                method: \"GET\"\n            });\n            if (!resp.ok) {\n                console.warn(\"⚠️ Polling chat API status \".concat(resp.status, \" na tentativa \").concat(attempt + 1));\n                continue;\n            }\n            const data = await resp.json();\n            var _data_messages;\n            const messages = (_data_messages = data === null || data === void 0 ? void 0 : data.messages) !== null && _data_messages !== void 0 ? _data_messages : [];\n            const lastIdx = typeof (data === null || data === void 0 ? void 0 : data.lastIdx) === \"number\" ? data.lastIdx : cursor;\n            let newCount = 0;\n            messages.forEach((m)=>{\n                var _m_text;\n                const txt = ((_m_text = m === null || m === void 0 ? void 0 : m.text) !== null && _m_text !== void 0 ? _m_text : \"\").trim();\n                if (!txt || txt.toLowerCase() === \"null\" || isWorkflowStartedResponse(txt)) {\n                    return;\n                }\n                const normalized = normalizeMessage(txt);\n                if (!received.has(normalized)) {\n                    received.add(normalized);\n                    newCount++;\n                    console.log(\"✅ Nova mensagem do polling (\".concat(newCount, \"):\"), txt.substring(0, 100));\n                    onNewMessage(txt);\n                } else {\n                    console.log(\"⚠️ Mensagem duplicada ignorada no polling:\", txt.substring(0, 50));\n                }\n            });\n            if (newCount > 0) {\n                cursor = lastIdx;\n                consecutiveEmpty = 0;\n            } else {\n                consecutiveEmpty++;\n            }\n            if (consecutiveEmpty >= emptyAttemptsToStop && attempt + 1 >= minAttemptsBeforeStop) {\n                break;\n            }\n        } catch (err) {\n            console.warn(\"⚠️ Erro ao fazer polling da chat API na tentativa \".concat(attempt + 1, \":\"), err);\n        // continua tentando\n        }\n    }\n}\n/**\r\n * Extrai a resposta do formato retornado pelo N8N\r\n * Suporta diferentes formatos de resposta, incluindo arrays JSON\r\n */ function extractResponse(data) {\n    // Se for string, tenta parsear como JSON primeiro\n    if (typeof data === \"string\") {\n        // Tenta parsear como JSON\n        try {\n            const parsed = JSON.parse(data);\n            // Se parseou com sucesso, processa o objeto/array\n            return extractResponse(parsed);\n        } catch (e) {\n            // Se não for JSON válido, retorna a string como está\n            return data;\n        }\n    }\n    // Se for um array, pega o primeiro elemento\n    if (Array.isArray(data) && data.length > 0) {\n        const firstItem = data[0];\n        // Se o primeiro item tiver campo \"output\", retorna ele\n        if (firstItem && typeof firstItem === \"object\" && \"output\" in firstItem) {\n            return String(firstItem.output || \"\");\n        }\n        // Se não, tenta extrair do primeiro item\n        return extractResponse(firstItem);\n    }\n    // Se for objeto, tenta diferentes campos comuns de resposta\n    if (data && typeof data === \"object\") {\n        // Prioriza o campo \"text\" (formato comum do N8N)\n        if (\"text\" in data && data.text) {\n            console.log('\\uD83D\\uDCDD Campo \"text\" encontrado:', String(data.text).substring(0, 100));\n            return String(data.text);\n        }\n        // Prioriza o campo \"output\" se existir\n        if (\"output\" in data && data.output) {\n            return String(data.output);\n        }\n        // Tenta outros campos comuns\n        if (data.response) return String(data.response);\n        if (data.message) return String(data.message);\n        // Tenta campos aninhados\n        if (data.output && typeof data.output === \"object\") {\n            if (\"message\" in data.output) return String(data.output.message);\n            if (\"response\" in data.output) return String(data.output.response);\n            if (\"text\" in data.output) return String(data.output.text);\n        }\n    }\n    // Se não encontrar nenhum campo conhecido, retorna o JSON stringificado\n    return JSON.stringify(data);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy93ZWJob29rU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Q0FFQyxHQUVELE1BQU1BLGNBQWM7QUFDcEIsTUFBTUMsZUFBZTtBQVdyQjs7OztDQUlDLEdBQ00sU0FBU0M7SUFDZCxPQUFPLFdBQXlCQyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBK0MsT0FBNUNGLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHO0FBQzFFO0FBYUEsOEVBQThFO0FBQzlFLE1BQU1DLDRCQUE0QjtJQUNoQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7O0NBRUMsR0FDTSxTQUFTQywwQkFBMEJDLFFBQWdCO0lBQ3hELE1BQU1DLGdCQUFnQkQsU0FBU0UsV0FBVztJQUMxQyxPQUFPSiwwQkFBMEJLLElBQUksQ0FBQ0MsQ0FBQUEsTUFBT0gsY0FBY0ksUUFBUSxDQUFDRDtBQUN0RTtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELGVBQWVFLGdCQUNiQyxTQUFpQixFQUNqQkMsWUFBdUM7UUFDdkNDLGtCQUFBQSxpRUFBNEIsRUFBRSxFQUM5QkMsY0FBQUEsaUVBQXNCLElBQ3RCQyxhQUFBQSxpRUFBcUIsTUFDckJDLHNCQUFBQSxpRUFBOEI7SUFFOUJDLFFBQVFDLEdBQUcsQ0FBQywyRUFBc0ZKLE9BQXJCSCxXQUFVLGdCQUF1QixPQUFaRyxhQUFZO0lBQzlHRyxRQUFRQyxHQUFHLENBQUMsZ0VBQTBFLE9BQXZCTCxnQkFBZ0JNLE1BQU07SUFFckYsTUFBTUMsbUJBQW1CLElBQUlDLElBQVlSLGtCQUFrQix1REFBdUQ7SUFDbEgsSUFBSVMsMkJBQTJCLEdBQUcsMERBQTBEO0lBRTVGLElBQUssSUFBSUMsVUFBVSxHQUFHQSxVQUFVVCxhQUFhUyxVQUFXO1FBQ3RELGtFQUFrRTtRQUNsRSxJQUFJQSxVQUFVLEdBQUc7WUFDZixNQUFNLElBQUlDLFFB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WUFDakUsSUFBSSxVQUFVbUMsS0FBSzRELE1BQU0sRUFBRSxPQUFPRCxPQUFPM0QsS0FBSzRELE1BQU0sQ0FBQzFELElBQUk7UUFDM0Q7SUFDRjtJQUVBLHdFQUF3RTtJQUN4RSxPQUFPVixLQUFLQyxTQUFTLENBQUNPO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy93ZWJob29rU2VydmljZS50cz81Y2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXJ2acOnbyBwYXJhIGNvbXVuaWNhw6fDo28gY29tIG8gd2ViaG9vayBOOE5cclxuICovXHJcblxyXG5jb25zdCBXRUJIT09LX1VSTCA9IFwiaHR0cHM6Ly93ZWJob29rLmFnZW50ZW13ZC5jb20vd2ViaG9vay85ZGU0NzFiZC00Mjk2LTRjYzgtYmM0MC1mMmVhMWQxOWY2ZGRcIjtcclxuY29uc3QgQ0hBVF9BUElfVVJMID0gXCIvYXBpL2NoYXQvbWVzc2FnZXNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEFnZW50VHlwZSA9IFwic2RyXCIgfCBcImVjb21tZXJjZVwiIHwgXCJhZ2VuZGFtZW50b1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXZWJob29rTWVzc2FnZSB7XHJcbiAgbWVzc2FnZTogc3RyaW5nO1xyXG4gIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gIHNlc3Npb25JZDogc3RyaW5nO1xyXG4gIGFnZW50VHlwZTogQWdlbnRUeXBlO1xyXG59XHJcblxyXG4vKipcclxuICogR2VyYSB1bSBJRCDDum5pY28gcGFyYSBhIHNlc3PDo28gb3UgcmVjdXBlcmEgbyBleGlzdGVudGUgZG8gc2Vzc2lvblN0b3JhZ2VcclxuICogTyBJRCDDqSDDum5pY28gcG9yIHNlc3PDo28gZG8gbmF2ZWdhZG9yIChyZWNhcnJlZ2EgcXVhbmRvIGEgcMOhZ2luYSDDqSByZWNhcnJlZ2FkYSlcclxuICogQHJldHVybnMgSUQgw7puaWNvIGRhIHNlc3PDo29cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXNzaW9uSWQoKTogc3RyaW5nIHtcclxuICByZXR1cm4gYHNlc3Npb25fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSl9YDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXZWJob29rUmVzcG9uc2Uge1xyXG4gIHJlc3BvbnNlPzogc3RyaW5nO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgdGV4dD86IHN0cmluZztcclxuICBzdGF0dXM/OiBzdHJpbmc7XHJcbiAgb3V0cHV0Pzoge1xyXG4gICAgbWVzc2FnZT86IHN0cmluZztcclxuICAgIHJlc3BvbnNlPzogc3RyaW5nO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIE1lbnNhZ2VucyBxdWUgaW5kaWNhbSBxdWUgbyB3b3JrZmxvdyBmb2kgaW5pY2lhZG8gbWFzIGFpbmRhIG7Do28gaMOhIHJlc3Bvc3RhXHJcbmNvbnN0IFdPUktGTE9XX1NUQVJURURfTUVTU0FHRVMgPSBbXHJcbiAgXCJ3b3JrZmxvdyBmb2kgaW5pY2lhZG9cIixcclxuICBcIndvcmtmbG93IGluaWNpYWRvXCIsXHJcbiAgXCJ3b3JrZmxvdyBzdGFydGVkXCIsXHJcbiAgXCJwcm9jZXNzYW5kb1wiLFxyXG4gIFwicHJvY2Vzc2FuZG8gc3VhIG1lbnNhZ2VtXCIsXHJcbiAgXCJhZ3VhcmRlXCIsXHJcbiAgXCJ3b3JrZmxvdyB3YXMgc3RhcnRlZFwiLFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIFZlcmlmaWNhIHNlIGEgcmVzcG9zdGEgaW5kaWNhIHF1ZSBvIHdvcmtmbG93IGZvaSBpbmljaWFkbyBtYXMgYWluZGEgbsOjbyBow6EgcmVzcG9zdGEgZmluYWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKHJlc3BvbnNlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICBjb25zdCBsb3dlclJlc3BvbnNlID0gcmVzcG9uc2UudG9Mb3dlckNhc2UoKTtcclxuICByZXR1cm4gV09SS0ZMT1dfU1RBUlRFRF9NRVNTQUdFUy5zb21lKG1zZyA9PiBsb3dlclJlc3BvbnNlLmluY2x1ZGVzKG1zZykpO1xyXG59XHJcblxyXG4vKipcclxuICogRmF6IHBvbGxpbmcgcGFyYSB2ZXJpZmljYXIgc2UgaMOhIG1lbnNhZ2VucyBkaXNwb27DrXZlaXNcclxuICogSU1QT1JUQU5URTogQXBlbmFzIHZlcmlmaWNhIHN0YXR1cywgTsODTyBpbmljaWEgbm92YXMgZXhlY3XDp8O1ZXNcclxuICogQHBhcmFtIHNlc3Npb25JZCAtIElEIGRhIHNlc3PDo29cclxuICogQHBhcmFtIG9uTmV3TWVzc2FnZSAtIENhbGxiYWNrIGNoYW1hZG8gcGFyYSBjYWRhIG5vdmEgbWVuc2FnZW0gcmVjZWJpZGFcclxuICogQHBhcmFtIG1heEF0dGVtcHRzIC0gTsO6bWVybyBtw6F4aW1vIGRlIHRlbnRhdGl2YXMgKHBhZHLDo286IDMwID0gNjAgc2VndW5kb3MpXHJcbiAqIEBwYXJhbSBpbnRlcnZhbE1zIC0gSW50ZXJ2YWxvIGVudHJlIHRlbnRhdGl2YXMgZW0gbXMgKHBhZHLDo286IDIwMDAgPSAyIHNlZ3VuZG9zKVxyXG4gKiBAcGFyYW0gZW1wdHlBdHRlbXB0c1RvU3RvcCAtIE7Dum1lcm8gZGUgdGVudGF0aXZhcyB2YXppYXMgY29uc2VjdXRpdmFzIHBhcmEgcGFyYXIgKHBhZHLDo286IDIpXHJcbiAqIEByZXR1cm5zIHRydWUgc2UgcmVjZWJldSBtZW5zYWdlbnMsIGZhbHNlIHNlIHRpbWVvdXRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHBvbGxGb3JNZXNzYWdlcyhcclxuICBzZXNzaW9uSWQ6IHN0cmluZyxcclxuICBvbk5ld01lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgaW5pdGlhbE1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdLCAvLyBNZW5zYWdlbnMgasOhIHJlY2ViaWRhcyBuYSBwcmltZWlyYSByZXNwb3N0YVxyXG4gIG1heEF0dGVtcHRzOiBudW1iZXIgPSAzMCxcclxuICBpbnRlcnZhbE1zOiBudW1iZXIgPSAyMDAwLFxyXG4gIGVtcHR5QXR0ZW1wdHNUb1N0b3A6IG51bWJlciA9IDJcclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgY29uc29sZS5sb2coYPCflIQgSW5pY2lhbmRvIHBvbGxpbmcgQVBFTkFTIHBhcmEgdmVyaWZpY2FyIHN0YXR1cy4gU2Vzc2lvbklkOiAke3Nlc3Npb25JZH0sIG3DoXhpbW8gJHttYXhBdHRlbXB0c30gdGVudGF0aXZhc2ApO1xyXG4gIGNvbnNvbGUubG9nKGDwn5OLIE1lbnNhZ2VucyBqw6EgcmVjZWJpZGFzIG5hIHByaW1laXJhIHJlc3Bvc3RhOiAke2luaXRpYWxNZXNzYWdlcy5sZW5ndGh9YCk7XHJcbiAgXHJcbiAgY29uc3QgcmVjZWl2ZWRNZXNzYWdlcyA9IG5ldyBTZXQ8c3RyaW5nPihpbml0aWFsTWVzc2FnZXMpOyAvLyBJbmNsdWkgbWVuc2FnZW5zIGrDoSByZWNlYmlkYXMgcGFyYSBldml0YXIgZHVwbGljYXRhc1xyXG4gIGxldCBjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMgPSAwOyAvLyBDb250YWRvciBkZSB0ZW50YXRpdmFzIGNvbnNlY3V0aXZhcyBzZW0gbm92YXMgbWVuc2FnZW5zXHJcbiAgXHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XHJcbiAgICAvLyBBZ3VhcmRhIGFudGVzIGRlIGZhemVyIGEgcHLDs3hpbWEgdGVudGF0aXZhIChleGNldG8gbmEgcHJpbWVpcmEpXHJcbiAgICBpZiAoYXR0ZW1wdCA+IDApIHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsTXMpKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJTVBPUlRBTlRFOiBBcGVuYXMgdmVyaWZpY2Egc3RhdHVzLCBOw4NPIGVudmlhIG1lbnNhZ2VtIG5lbSBhZ2VudFR5cGVcclxuICAgICAgLy8gSXNzbyBldml0YSBpbmljaWFyIG5vdmFzIGV4ZWN1w6fDtWVzIGRvIHdvcmtmbG93XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goV0VCSE9PS19VUkwsIHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXHJcbiAgICAgICAgICBjaGVja1N0YXR1czogdHJ1ZSwgLy8gSW5kaWNhIHF1ZSDDqSBBUEVOQVMgdW1hIHZlcmlmaWNhw6fDo28gZGUgc3RhdHVzXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xyXG4gICAgICAgIGxldCBkYXRhOiBXZWJob29rUmVzcG9uc2UgfCBzdHJpbmcgfCBhbnk7XHJcblxyXG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcclxuICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICBkYXRhID0gdGV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByb2Nlc3NhIG3Dumx0aXBsYXMgbWVuc2FnZW5zIHNlIHZpZXJlbSBlbSBhcnJheVxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZXh0cmFjdE1lc3NhZ2VzKGRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OmIFRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfS8ke21heEF0dGVtcHRzfTogJHttZXNzYWdlcy5sZW5ndGh9IG1lbnNhZ2VucyBleHRyYcOtZGFzYCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG5ld01lc3NhZ2VzQ291bnQgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoYW1hIG8gY2FsbGJhY2sgcGFyYSBjYWRhIG5vdmEgbWVuc2FnZW1cclxuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtc2c6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgdHJpbW1lZE1zZyA9IG1zZy50cmltKCk7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRyaW1tZWRNc2cubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICAhaXNXb3JrZmxvd1N0YXJ0ZWRSZXNwb25zZSh0cmltbWVkTXNnKSAmJlxyXG4gICAgICAgICAgICB0cmltbWVkTXNnLnRvTG93ZXJDYXNlKCkgIT09IFwibnVsbFwiICYmXHJcbiAgICAgICAgICAgIHRyaW1tZWRNc2cudG9Mb3dlckNhc2UoKSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxyXG4gICAgICAgICAgICAhcmVjZWl2ZWRNZXNzYWdlcy5oYXModHJpbW1lZE1zZylcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLmFkZCh0cmltbWVkTXNnKTtcclxuICAgICAgICAgICAgbmV3TWVzc2FnZXNDb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIE5vdmEgbWVuc2FnZW0gJHtuZXdNZXNzYWdlc0NvdW50fSByZWNlYmlkYSBuYSB0ZW50YXRpdmEgJHthdHRlbXB0ICsgMX06YCwgdHJpbW1lZE1zZy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgICAgICAgIG9uTmV3TWVzc2FnZSh0cmltbWVkTXNnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZSByZWNlYmV1IG5vdmFzIG1lbnNhZ2VucywgcmVzZXRhIG8gY29udGFkb3IgZGUgdGVudGF0aXZhcyB2YXppYXNcclxuICAgICAgICBpZiAobmV3TWVzc2FnZXNDb3VudCA+IDApIHtcclxuICAgICAgICAgIGNvbnNlY3V0aXZlRW1wdHlBdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBUb3RhbCBkZSBtZW5zYWdlbnMgcmVjZWJpZGFzIGF0w6kgYWdvcmE6ICR7cmVjZWl2ZWRNZXNzYWdlcy5zaXplfWApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMrKztcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7MgVGVudGF0aXZhICR7YXR0ZW1wdCArIDF9LyR7bWF4QXR0ZW1wdHN9OiBTZW0gbm92YXMgbWVuc2FnZW5zICgke2NvbnNlY3V0aXZlRW1wdHlBdHRlbXB0c30vJHtlbXB0eUF0dGVtcHRzVG9TdG9wfSB0ZW50YXRpdmFzIHZhemlhcyBjb25zZWN1dGl2YXMpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFBhcmEgbyBwb2xsaW5nIHNlIG7Do28gaG91dmVyIG5vdmFzIG1lbnNhZ2VucyBwb3IgdsOhcmlhcyB0ZW50YXRpdmFzIGNvbnNlY3V0aXZhc1xyXG4gICAgICAgIGlmIChjb25zZWN1dGl2ZUVtcHR5QXR0ZW1wdHMgPj0gZW1wdHlBdHRlbXB0c1RvU3RvcCkge1xyXG4gICAgICAgICAgaWYgKHJlY2VpdmVkTWVzc2FnZXMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKPue+4jyBQYXJhbmRvIHBvbGxpbmc6ICR7ZW1wdHlBdHRlbXB0c1RvU3RvcH0gdGVudGF0aXZhcyBjb25zZWN1dGl2YXMgc2VtIG5vdmFzIG1lbnNhZ2Vucy4gVG90YWw6ICR7cmVjZWl2ZWRNZXNzYWdlcy5zaXplfSBtZW5zYWdlbnMgcmVjZWJpZGFzYCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRlbXB0ID49IDUpIHtcclxuICAgICAgICAgICAgLy8gU2UgbsOjbyByZWNlYmV1IG5lbmh1bWEgbWVuc2FnZW0gYXDDs3MgNSB0ZW50YXRpdmFzLCB0YW1iw6ltIHBhcmFcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKPue+4jyBQYXJhbmRvIHBvbGxpbmc6IE5lbmh1bWEgbWVuc2FnZW0gcmVjZWJpZGEgYXDDs3MgJHthdHRlbXB0ICsgMX0gdGVudGF0aXZhc2ApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gVGVudGF0aXZhICR7YXR0ZW1wdCArIDF9OiBTdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIEVycm8gbmEgdGVudGF0aXZhICR7YXR0ZW1wdCArIDF9IGRlIHBvbGxpbmc6YCwgZXJyb3IpO1xyXG4gICAgICAvLyBDb250aW51YSB0ZW50YW5kbyBtZXNtbyBjb20gZXJyb1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFzTWVzc2FnZXMgPSByZWNlaXZlZE1lc3NhZ2VzLnNpemUgPiAwO1xyXG4gIGlmICghaGFzTWVzc2FnZXMpIHtcclxuICAgIGNvbnNvbGUud2Fybihg4o+x77iPIFRpbWVvdXQ6IE7Do28gZm9pIHBvc3PDrXZlbCBvYnRlciBtZW5zYWdlbnMgYXDDs3MgJHttYXhBdHRlbXB0c30gdGVudGF0aXZhc2ApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIFBvbGxpbmcgZmluYWxpemFkby4gVG90YWwgZGUgJHtyZWNlaXZlZE1lc3NhZ2VzLnNpemV9IG1lbnNhZ2VucyByZWNlYmlkYXNgKTtcclxuICB9XHJcbiAgcmV0dXJuIGhhc01lc3NhZ2VzO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0cmFpIG3Dumx0aXBsYXMgbWVuc2FnZW5zIGRvIGZvcm1hdG8gcmV0b3JuYWRvIHBlbG8gTjhOXHJcbiAqIFN1cG9ydGEgYXJyYXlzIGRlIG1lbnNhZ2VucyBvdSBtZW5zYWdlbSDDum5pY2FcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhkYXRhOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgY29uc29sZS5sb2coXCLwn5SNIGV4dHJhY3RNZXNzYWdlcyBjaGFtYWRvIGNvbTpcIiwgdHlwZW9mIGRhdGEsIEFycmF5LmlzQXJyYXkoZGF0YSkgPyBgYXJyYXlbJHtkYXRhLmxlbmd0aH1dYCA6IGRhdGEpO1xyXG4gIFxyXG4gIC8vIFNlIGZvciBzdHJpbmcsIHRlbnRhIHBhcnNlYXIgY29tbyBKU09OXHJcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICByZXR1cm4gZXh0cmFjdE1lc3NhZ2VzKHBhcnNlZCk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgLy8gU2UgbsOjbyBmb3IgSlNPTiB2w6FsaWRvLCByZXRvcm5hIGNvbW8gYXJyYXkgY29tIHVtYSBtZW5zYWdlbVxyXG4gICAgICByZXR1cm4gZGF0YS50cmltKCkgPyBbZGF0YV0gOiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNlIGZvciB1bSBhcnJheSwgcHJvY2Vzc2EgY2FkYSBpdGVtXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OmIFByb2Nlc3NhbmRvIGFycmF5IGNvbSAke2RhdGEubGVuZ3RofSBpdGVuc2ApO1xyXG4gICAgY29uc3QgbWVzc2FnZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFByb2Nlc3NhbmRvIGl0ZW0gJHtpbmRleCArIDF9LyR7ZGF0YS5sZW5ndGh9OmAsIGl0ZW0pO1xyXG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSBleHRyYWN0UmVzcG9uc2UoaXRlbSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIEl0ZW0gJHtpbmRleCArIDF9IGV4dHJhw61kbzpgLCBleHRyYWN0ZWQ/LnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgICAgaWYgKGV4dHJhY3RlZCAmJiBleHRyYWN0ZWQudHJpbSgpKSB7XHJcbiAgICAgICAgbWVzc2FnZXMucHVzaChleHRyYWN0ZWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBJdGVtICR7aW5kZXggKyAxfSBuw6NvIHRpbmhhIGNvbnRlw7pkbyB2w6FsaWRvYCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coYOKchSBUb3RhbCBkZSAke21lc3NhZ2VzLmxlbmd0aH0gbWVuc2FnZW5zIGV4dHJhw61kYXMgZG8gYXJyYXlgKTtcclxuICAgIHJldHVybiBtZXNzYWdlcztcclxuICB9XHJcblxyXG4gIC8vIFNlIGZvciBvYmpldG8sIGV4dHJhaSBhIG1lbnNhZ2VtXHJcbiAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IGV4dHJhY3RSZXNwb25zZShkYXRhKTtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OdIE9iamV0byBleHRyYcOtZG86YCwgZXh0cmFjdGVkPy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICByZXR1cm4gZXh0cmFjdGVkICYmIGV4dHJhY3RlZC50cmltKCkgPyBbZXh0cmFjdGVkXSA6IFtdO1xyXG4gICAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhcIuKaoO+4jyBUaXBvIGRlIGRhZG9zIG7Do28gcmVjb25oZWNpZG8sIHJldG9ybmFuZG8gYXJyYXkgdmF6aW9cIik7XHJcbiAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG4vKipcclxuICogRW52aWEgdW1hIG1lbnNhZ2VtIHBhcmEgbyB3ZWJob29rIE44TiBlIHJlY2ViZSBtw7psdGlwbGFzIG1lbnNhZ2VucyBzZXBhcmFkYXNcclxuICogU2UgYSByZXNwb3N0YSBpbmljaWFsIGZvciBcIndvcmtmbG93IGluaWNpYWRvXCIsIGZheiBwb2xsaW5nIGF0w6kgcmVjZWJlciBhcyBtZW5zYWdlbnNcclxuICogQHBhcmFtIG1lc3NhZ2UgLSBBIG1lbnNhZ2VtIGRvIHVzdcOhcmlvXHJcbiAqIEBwYXJhbSBhZ2VudFR5cGUgLSBUaXBvIGRvIGFnZW50ZSBJQSAoc2RyLCBlY29tbWVyY2UsIGFnZW5kYW1lbnRvKVxyXG4gKiBAcGFyYW0gb25OZXdNZXNzYWdlIC0gQ2FsbGJhY2sgY2hhbWFkbyBwYXJhIGNhZGEgbm92YSBtZW5zYWdlbSByZWNlYmlkYSBkYSBJQVxyXG4gKiBAcGFyYW0gb25Qb2xsaW5nIC0gQ2FsbGJhY2sgY2hhbWFkbyBkdXJhbnRlIG8gcG9sbGluZyAocGFyYSBhbmltYcOnw6NvKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRNZXNzYWdlVG9XZWJob29rKFxyXG4gIG1lc3NhZ2U6IHN0cmluZyxcclxuICBhZ2VudFR5cGU6IEFnZW50VHlwZSxcclxuICBzZXNzaW9uSWQ6IHN0cmluZyxcclxuICBvbk5ld01lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgb25Qb2xsaW5nPzogKGlzUG9sbGluZzogYm9vbGVhbikgPT4gdm9pZFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKCFzZXNzaW9uSWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2Vzc2lvbklkIMOpIG9icmlnYXTDs3JpbyBwYXJhIGVudmlhciBtZW5zYWdlbnNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGF5bG9hZDogV2ViaG9va01lc3NhZ2UgPSB7XHJcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UudHJpbSgpLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXHJcbiAgICAgIGFnZW50VHlwZTogYWdlbnRUeXBlLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2cgcGFyYSBkZWJ1Z1xyXG4gICAgY29uc29sZS5sb2coXCJFbnZpYW5kbyBtZW5zYWdlbSBwYXJhIHdlYmhvb2s6XCIsIHtcclxuICAgICAgdXJsOiBXRUJIT09LX1VSTCxcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goV0VCSE9PS19VUkwsIHtcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiUmVzcG9zdGEgZG8gd2ViaG9vazpcIiwge1xyXG4gICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcclxuICAgICAgb2s6IHJlc3BvbnNlLm9rLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkuY2F0Y2goKCkgPT4gcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIG5hIHJlc3Bvc3RhIGRvIHdlYmhvb2s6XCIsIHtcclxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxyXG4gICAgICAgIGJvZHk6IGVycm9yVGV4dCxcclxuICAgICAgfSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJybyBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlbnRhIHBhcnNlYXIgY29tbyBKU09OLCBtYXMgdGFtYsOpbSBzdXBvcnRhIHRleHRvIHNpbXBsZXNcclxuICAgIGxldCBkYXRhOiBXZWJob29rUmVzcG9uc2UgfCBzdHJpbmc7XHJcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XHJcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICAgIGRhdGEgPSB0ZXh0O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIHBhcnNlYXIgcmVzcG9zdGE6XCIsIHBhcnNlRXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvIGFvIHByb2Nlc3NhciByZXNwb3N0YSBkbyB3ZWJob29rXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiRGFkb3MgcGFyc2VhZG9zOlwiLCBkYXRhKTtcclxuXHJcbiAgICAvLyBFeHRyYWkgYXMgbWVuc2FnZW5zIGRvIGZvcm1hdG8gcmV0b3JuYWRvIHBlbG8gTjhOXHJcbiAgICBjb25zdCBtZXNzYWdlcyA9IGV4dHJhY3RNZXNzYWdlcyhkYXRhKTtcclxuICAgIGNvbnNvbGUubG9nKFwiTWVuc2FnZW5zIGV4dHJhw61kYXM6XCIsIG1lc3NhZ2VzKTtcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2Egc2UgbyB3b3JrZmxvdyBmb2kgaW5pY2lhZG8gKGluZGljYSBxdWUgbWFpcyBtZW5zYWdlbnMgcG9kZW0gdmlyKVxyXG4gICAgY29uc3QgaXNXb3JrZmxvd1N0YXJ0ZWQgPSBtZXNzYWdlcy5zb21lKG1zZyA9PiBpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKG1zZykpO1xyXG4gICAgY29uc3QgdmFsaWRNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihtc2cgPT4gIWlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UobXNnKSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5OKIFdvcmtmbG93IGluaWNpYWRvPyAke2lzV29ya2Zsb3dTdGFydGVkfSwgTWVuc2FnZW5zIHbDoWxpZGFzIG5hIHJlc3Bvc3RhIGluaWNpYWw6ICR7dmFsaWRNZXNzYWdlcy5sZW5ndGh9YCk7XHJcbiAgICBcclxuICAgIC8vIFByb2Nlc3NhIG1lbnNhZ2VucyBkYSByZXNwb3N0YSBpbmljaWFsIHByaW1laXJvIChzZSBob3V2ZXIpXHJcbiAgICBpZiAodmFsaWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OoIFByb2Nlc3NhbmRvICR7dmFsaWRNZXNzYWdlcy5sZW5ndGh9IG1lbnNhZ2VucyBkYSByZXNwb3N0YSBpbmljaWFsYCk7XHJcbiAgICAgIHZhbGlkTWVzc2FnZXMuZm9yRWFjaCgobXNnLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OkIEVudmlhbmRvIG1lbnNhZ2VtICR7aW5kZXggKyAxfS8ke3ZhbGlkTWVzc2FnZXMubGVuZ3RofSBkYSByZXNwb3N0YSBpbmljaWFsOmAsIG1zZy5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgICAgb25OZXdNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBDYWxsYmFjayBvbk5ld01lc3NhZ2UgY2hhbWFkbyBwYXJhIG1lbnNhZ2VtICR7aW5kZXggKyAxfWApO1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBUb2RhcyBhcyAke3ZhbGlkTWVzc2FnZXMubGVuZ3RofSBtZW5zYWdlbnMgZGEgcmVzcG9zdGEgaW5pY2lhbCBmb3JhbSBlbnZpYWRhc2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBOZW5odW1hIG1lbnNhZ2VtIHbDoWxpZGEgZW5jb250cmFkYSBuYSByZXNwb3N0YSBpbmljaWFsYCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNlbXByZSBmYXplbW9zIHBvbGxpbmcgbmEgQVBJIGludGVybmEgZGUgbWVuc2FnZW5zIHBhcmEgdHJhemVyIGFzIHJlc3Bvc3RhcyBxdWUgbyBmbHV4byBlbnZpb3UgdmlhIEhUVFAgUmVxdWVzdDFcclxuICAgIGNvbnNvbGUubG9nKFwi8J+UhCBJbmljaWFuZG8gcG9sbGluZyBuYSBBUEkgaW50ZXJuYSAvYXBpL2NoYXQvbWVzc2FnZXMgcGFyYSBidXNjYXIgcmVzcG9zdGFzIGRvIGZsdXhvXCIpO1xyXG4gICAgaWYgKG9uUG9sbGluZykgb25Qb2xsaW5nKHRydWUpO1xyXG4gICAgYXdhaXQgcG9sbENoYXRNZXNzYWdlcyhzZXNzaW9uSWQsIG9uTmV3TWVzc2FnZSwgdmFsaWRNZXNzYWdlcyk7XHJcbiAgICBpZiAob25Qb2xsaW5nKSBvblBvbGxpbmcoZmFsc2UpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBjb21wbGV0byBhbyBlbnZpYXIgbWVuc2FnZW0gcGFyYSB3ZWJob29rOlwiLCB7XHJcbiAgICAgIGVycm9yLFxyXG4gICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRXJybyBkZXNjb25oZWNpZG9cIixcclxuICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IHVuZGVmaW5lZCxcclxuICAgIH0pO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmF6IHBvbGxpbmcgbmEgQVBJIGludGVybmEgKC9hcGkvY2hhdC9tZXNzYWdlcykgcGFyYSBidXNjYXIgbWVuc2FnZW5zIHBlcnNpc3RpZGFzIHBlbG8gZmx1eG9cclxuICovXHJcbi8vIE5vcm1hbGl6YSBtZW5zYWdlbSBwYXJhIGNvbXBhcmHDp8OjbyAocmVtb3ZlIGVzcGHDp29zIGV4dHJhcywgcXVlYnJhcyBkZSBsaW5oYSwgZXRjKVxyXG5mdW5jdGlvbiBub3JtYWxpemVNZXNzYWdlKG1zZzogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gbXNnLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gcG9sbENoYXRNZXNzYWdlcyhcclxuICBzZXNzaW9uSWQ6IHN0cmluZyxcclxuICBvbk5ld01lc3NhZ2U6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgaW5pdGlhbE1lc3NhZ2VzOiBzdHJpbmdbXSA9IFtdLFxyXG4gIG1heEF0dGVtcHRzOiBudW1iZXIgPSA4MCwgICAgICAgICAgLy8gfjE2MHMgbm8gcGlvciBjYXNvICg4MCAqIDJzKVxyXG4gIGludGVydmFsTXM6IG51bWJlciA9IDIwMDAsICAgICAgICAgLy8gMnMgZW50cmUgdGVudGF0aXZhc1xyXG4gIGVtcHR5QXR0ZW1wdHNUb1N0b3A6IG51bWJlciA9IDgsICAgLy8gcGFyYSBhcMOzcyA4IHRlbnRhdGl2YXMgdmF6aWFzIHNlZ3VpZGFzXHJcbiAgbWluQXR0ZW1wdHNCZWZvcmVTdG9wOiBudW1iZXIgPSA2ICAvLyBnYXJhbnRlIGFvIG1lbm9zIDYgdGVudGF0aXZhcyBhbnRlcyBkZSBwYXJhclxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBsZXQgY3Vyc29yID0gLTE7XHJcbiAgbGV0IGNvbnNlY3V0aXZlRW1wdHkgPSAwO1xyXG4gIC8vIFVzYSBub3JtYWxpemHDp8OjbyBwYXJhIGNvbXBhcmHDp8OjbyBkZSBtZW5zYWdlbnNcclxuICBjb25zdCByZWNlaXZlZCA9IG5ldyBTZXQ8c3RyaW5nPihpbml0aWFsTWVzc2FnZXMubWFwKG5vcm1hbGl6ZU1lc3NhZ2UpKTtcclxuXHJcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XHJcbiAgICAvLyBlc3BlcmEgZW50cmUgdGVudGF0aXZhcywgZXhjZXRvIG5hIHByaW1laXJhXHJcbiAgICBpZiAoYXR0ZW1wdCA+IDApIHtcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgaW50ZXJ2YWxNcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVybCA9IGAke0NIQVRfQVBJX1VSTH0/c2Vzc2lvbklkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlc3Npb25JZCl9JmN1cnNvcj0ke2N1cnNvcn1gO1xyXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2godXJsLCB7IG1ldGhvZDogXCJHRVRcIiB9KTtcclxuICAgICAgaWYgKCFyZXNwLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gUG9sbGluZyBjaGF0IEFQSSBzdGF0dXMgJHtyZXNwLnN0YXR1c30gbmEgdGVudGF0aXZhICR7YXR0ZW1wdCArIDF9YCk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwLmpzb24oKTtcclxuICAgICAgY29uc3QgbWVzc2FnZXM6IHsgdGV4dD86IHN0cmluZyB9W10gPSBkYXRhPy5tZXNzYWdlcyA/PyBbXTtcclxuICAgICAgY29uc3QgbGFzdElkeDogbnVtYmVyID0gdHlwZW9mIGRhdGE/Lmxhc3RJZHggPT09IFwibnVtYmVyXCIgPyBkYXRhLmxhc3RJZHggOiBjdXJzb3I7XHJcblxyXG4gICAgICBsZXQgbmV3Q291bnQgPSAwO1xyXG4gICAgICBtZXNzYWdlcy5mb3JFYWNoKChtKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdHh0ID0gKG0/LnRleHQgPz8gXCJcIikudHJpbSgpO1xyXG4gICAgICAgIGlmICghdHh0IHx8IHR4dC50b0xvd2VyQ2FzZSgpID09PSBcIm51bGxcIiB8fCBpc1dvcmtmbG93U3RhcnRlZFJlc3BvbnNlKHR4dCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU1lc3NhZ2UodHh0KTtcclxuICAgICAgICBpZiAoIXJlY2VpdmVkLmhhcyhub3JtYWxpemVkKSkge1xyXG4gICAgICAgICAgcmVjZWl2ZWQuYWRkKG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgICAgbmV3Q291bnQrKztcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTm92YSBtZW5zYWdlbSBkbyBwb2xsaW5nICgke25ld0NvdW50fSk6YCwgdHh0LnN1YnN0cmluZygwLCAxMDApKTtcclxuICAgICAgICAgIG9uTmV3TWVzc2FnZSh0eHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE1lbnNhZ2VtIGR1cGxpY2FkYSBpZ25vcmFkYSBubyBwb2xsaW5nOmAsIHR4dC5zdWJzdHJpbmcoMCwgNTApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKG5ld0NvdW50ID4gMCkge1xyXG4gICAgICAgIGN1cnNvciA9IGxhc3RJZHg7XHJcbiAgICAgICAgY29uc2VjdXRpdmVFbXB0eSA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc2VjdXRpdmVFbXB0eSsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29uc2VjdXRpdmVFbXB0eSA+PSBlbXB0eUF0dGVtcHRzVG9TdG9wICYmIGF0dGVtcHQgKyAxID49IG1pbkF0dGVtcHRzQmVmb3JlU3RvcCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRXJybyBhbyBmYXplciBwb2xsaW5nIGRhIGNoYXQgQVBJIG5hIHRlbnRhdGl2YSAke2F0dGVtcHQgKyAxfTpgLCBlcnIpO1xyXG4gICAgICAvLyBjb250aW51YSB0ZW50YW5kb1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV4dHJhaSBhIHJlc3Bvc3RhIGRvIGZvcm1hdG8gcmV0b3JuYWRvIHBlbG8gTjhOXHJcbiAqIFN1cG9ydGEgZGlmZXJlbnRlcyBmb3JtYXRvcyBkZSByZXNwb3N0YSwgaW5jbHVpbmRvIGFycmF5cyBKU09OXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0UmVzcG9uc2UoZGF0YTogV2ViaG9va1Jlc3BvbnNlIHwgc3RyaW5nKTogc3RyaW5nIHtcclxuICAvLyBTZSBmb3Igc3RyaW5nLCB0ZW50YSBwYXJzZWFyIGNvbW8gSlNPTiBwcmltZWlyb1xyXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgLy8gVGVudGEgcGFyc2VhciBjb21vIEpTT05cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgIC8vIFNlIHBhcnNlb3UgY29tIHN1Y2Vzc28sIHByb2Nlc3NhIG8gb2JqZXRvL2FycmF5XHJcbiAgICAgIHJldHVybiBleHRyYWN0UmVzcG9uc2UocGFyc2VkKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICAvLyBTZSBuw6NvIGZvciBKU09OIHbDoWxpZG8sIHJldG9ybmEgYSBzdHJpbmcgY29tbyBlc3TDoVxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFNlIGZvciB1bSBhcnJheSwgcGVnYSBvIHByaW1laXJvIGVsZW1lbnRvXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBmaXJzdEl0ZW0gPSBkYXRhWzBdO1xyXG4gICAgLy8gU2UgbyBwcmltZWlybyBpdGVtIHRpdmVyIGNhbXBvIFwib3V0cHV0XCIsIHJldG9ybmEgZWxlXHJcbiAgICBpZiAoZmlyc3RJdGVtICYmIHR5cGVvZiBmaXJzdEl0ZW0gPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiBmaXJzdEl0ZW0pIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhmaXJzdEl0ZW0ub3V0cHV0IHx8IFwiXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gU2UgbsOjbywgdGVudGEgZXh0cmFpciBkbyBwcmltZWlybyBpdGVtXHJcbiAgICByZXR1cm4gZXh0cmFjdFJlc3BvbnNlKGZpcnN0SXRlbSk7XHJcbiAgfVxyXG5cclxuICAvLyBTZSBmb3Igb2JqZXRvLCB0ZW50YSBkaWZlcmVudGVzIGNhbXBvcyBjb211bnMgZGUgcmVzcG9zdGFcclxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgLy8gUHJpb3JpemEgbyBjYW1wbyBcInRleHRcIiAoZm9ybWF0byBjb211bSBkbyBOOE4pXHJcbiAgICBpZiAoXCJ0ZXh0XCIgaW4gZGF0YSAmJiBkYXRhLnRleHQpIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk50gQ2FtcG8gXCJ0ZXh0XCIgZW5jb250cmFkbzpgLCBTdHJpbmcoZGF0YS50ZXh0KS5zdWJzdHJpbmcoMCwgMTAwKSk7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0YS50ZXh0KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUHJpb3JpemEgbyBjYW1wbyBcIm91dHB1dFwiIHNlIGV4aXN0aXJcclxuICAgIGlmIChcIm91dHB1dFwiIGluIGRhdGEgJiYgZGF0YS5vdXRwdXQpIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhkYXRhLm91dHB1dCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFRlbnRhIG91dHJvcyBjYW1wb3MgY29tdW5zXHJcbiAgICBpZiAoZGF0YS5yZXNwb25zZSkgcmV0dXJuIFN0cmluZyhkYXRhLnJlc3BvbnNlKTtcclxuICAgIGlmIChkYXRhLm1lc3NhZ2UpIHJldHVybiBTdHJpbmcoZGF0YS5tZXNzYWdlKTtcclxuICAgIFxyXG4gICAgLy8gVGVudGEgY2FtcG9zIGFuaW5oYWRvc1xyXG4gICAgaWYgKGRhdGEub3V0cHV0ICYmIHR5cGVvZiBkYXRhLm91dHB1dCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICBpZiAoXCJtZXNzYWdlXCIgaW4gZGF0YS5vdXRwdXQpIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQubWVzc2FnZSk7XHJcbiAgICAgIGlmIChcInJlc3BvbnNlXCIgaW4gZGF0YS5vdXRwdXQpIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQucmVzcG9uc2UpO1xyXG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gZGF0YS5vdXRwdXQpIHJldHVybiBTdHJpbmcoZGF0YS5vdXRwdXQudGV4dCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTZSBuw6NvIGVuY29udHJhciBuZW5odW0gY2FtcG8gY29uaGVjaWRvLCByZXRvcm5hIG8gSlNPTiBzdHJpbmdpZmljYWRvXHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiV0VCSE9PS19VUkwiLCJDSEFUX0FQSV9VUkwiLCJjcmVhdGVTZXNzaW9uSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiV09SS0ZMT1dfU1RBUlRFRF9NRVNTQUdFUyIsImlzV29ya2Zsb3dTdGFydGVkUmVzcG9uc2UiLCJyZXNwb25zZSIsImxvd2VyUmVzcG9uc2UiLCJ0b0xvd2VyQ2FzZSIsInNvbWUiLCJtc2ciLCJpbmNsdWRlcyIsInBvbGxGb3JNZXNzYWdlcyIsInNlc3Npb25JZCIsIm9uTmV3TWVzc2FnZSIsImluaXRpYWxNZXNzYWdlcyIsIm1heEF0dGVtcHRzIiwiaW50ZXJ2YWxNcyIsImVtcHR5QXR0ZW1wdHNUb1N0b3AiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwicmVjZWl2ZWRNZXNzYWdlcyIsIlNldCIsImNvbnNlY3V0aXZlRW1wdHlBdHRlbXB0cyIsImF0dGVtcHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNoZWNrU3RhdHVzIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJvayIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiZGF0YSIsImpzb24iLCJ0ZXh0IiwibWVzc2FnZXMiLCJleHRyYWN0TWVzc2FnZXMiLCJuZXdNZXNzYWdlc0NvdW50IiwiZm9yRWFjaCIsInRyaW1tZWRNc2ciLCJ0cmltIiwiaGFzIiwiYWRkIiwic2l6ZSIsIndhcm4iLCJzdGF0dXMiLCJlcnJvciIsImhhc01lc3NhZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VkIiwicGFyc2UiLCJpdGVtIiwiaW5kZXgiLCJleHRyYWN0ZWQiLCJleHRyYWN0UmVzcG9uc2UiLCJwdXNoIiwic2VuZE1lc3NhZ2VUb1dlYmhvb2siLCJtZXNzYWdlIiwiYWdlbnRUeXBlIiwib25Qb2xsaW5nIiwiRXJyb3IiLCJwYXlsb2FkIiwidXJsIiwic3RhdHVzVGV4dCIsImVycm9yVGV4dCIsImNhdGNoIiwicGFyc2VFcnJvciIsImlzV29ya2Zsb3dTdGFydGVkIiwidmFsaWRNZXNzYWdlcyIsImZpbHRlciIsInBvbGxDaGF0TWVzc2FnZXMiLCJzdGFjayIsInVuZGVmaW5lZCIsIm5vcm1hbGl6ZU1lc3NhZ2UiLCJyZXBsYWNlIiwibWluQXR0ZW1wdHNCZWZvcmVTdG9wIiwiY3Vyc29yIiwiY29uc2VjdXRpdmVFbXB0eSIsInJlY2VpdmVkIiwibWFwIiwiciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3AiLCJsYXN0SWR4IiwibmV3Q291bnQiLCJtIiwidHh0Iiwibm9ybWFsaXplZCIsImVyciIsImZpcnN0SXRlbSIsIlN0cmluZyIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/webhookService.ts\n"));

/***/ })

});